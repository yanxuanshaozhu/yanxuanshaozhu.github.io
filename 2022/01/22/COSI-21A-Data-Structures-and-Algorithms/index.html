<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanxuanshaozhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Lecture 01 2022&#x2F;01&#x2F;19">
<meta property="og:type" content="article">
<meta property="og:title" content="COSI 21A Data Structures and Algorithms">
<meta property="og:url" content="https://yanxuanshaozhu.github.io/2022/01/22/COSI-21A-Data-Structures-and-Algorithms/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="Lecture 01 2022&#x2F;01&#x2F;19">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Courses/COSI21A/right_rotation.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Courses/COSI21A/left_rotation.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Courses/COSI21A/left_right_rotation.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Courses/COSI21A/right_left_rotation.png">
<meta property="article:published_time" content="2022-01-23T03:56:51.000Z">
<meta property="article:modified_time" content="2023-05-06T14:36:24.000Z">
<meta property="article:author" content="Yanxuanshaozhu">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yanxuanshaozhu.github.io/images/Courses/COSI21A/right_rotation.png">

<link rel="canonical" href="https://yanxuanshaozhu.github.io/2022/01/22/COSI-21A-Data-Structures-and-Algorithms/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>COSI 21A Data Structures and Algorithms | My Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-portfolio">

    <a href="/portfolio/" rel="section"><i class="fas fa-wallet fa-fw"></i>Portfolio</a>

  </li>
        <li class="menu-item menu-item-memories">

    <a href="/memories/" rel="section"><i class="fas fa-camera fa-fw"></i>Memories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yanxuanshaozhu.github.io/2022/01/22/COSI-21A-Data-Structures-and-Algorithms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yanxuanshaozhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          COSI 21A Data Structures and Algorithms
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-22 22:56:51" itemprop="dateCreated datePublished" datetime="2022-01-22T22:56:51-05:00">2022-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-06 10:36:24" itemprop="dateModified" datetime="2023-05-06T10:36:24-04:00">2023-05-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>55k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>50 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="lecture-01-20220119">Lecture 01 2022/01/19</h2>
<span id="more"></span>
<ol type="1">
<li>Data Structure
<ul>
<li>A data structure is a way to store and organize data in order to
facilitate access and modifications</li>
<li>No single data structure well for all purpose</li>
<li>Each data structure has unique properties that make it well suited
to a certain type of data</li>
</ul></li>
<li>Algorithm
<ul>
<li>An algorithm is any well-defined computational procedure that takes
some value, or set ov values as input and produces some value, or set of
values, as output</li>
<li>Analysis of algorithm complexity:
<ul>
<li>Mathematical analysis</li>
<li>Independent of the machine the algorithm runs on, and the language
used for programming</li>
</ul></li>
<li>Pseudocode: less formal than programming language, but more precise
than English</li>
</ul></li>
</ol>
<h2 id="lecture-02-20220120">Lecture 02 2022/01/20</h2>
<ol type="1">
<li>Pseudocode
<ul>
<li>Description
<ul>
<li>For human eyes only</li>
<li>A mixture of natural language and high-level programming
constructs</li>
<li>Less detailed than a program</li>
<li>Hides program design issues</li>
<li>Preferred notation to describe algorithms</li>
</ul></li>
<li>Syntax
<ul>
<li>Algorithm: should be titled to concisely describe what it does</li>
<li>Input and output: each algorithm must describe its input and output
restrictions in English</li>
<li>Tabbing: no braces are used, tabs are used to indicate scope</li>
<li>Expressions
<ul>
<li>Standard mathematical symbols for arithmetic and boolean
expressions</li>
<li><span class="math inline">\(\leftarrow\)</span> for assignment
(equivalent to <code>=</code> operator)</li>
<li><code>=</code> used for equality (equivalent to <code>==</code>
operator)</li>
</ul></li>
<li>Control flow <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- if statement</span></span><br><span class="line"><span class="keyword">if</span> condition <span class="keyword">then</span></span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  statement</span><br><span class="line"><span class="comment">-- for loop</span></span><br><span class="line"><span class="comment">-- bothe the initial-value and final-value are inclusive</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">variable</span> &lt;- initial-value <span class="keyword">to</span> final-value do</span><br><span class="line">  statement</span><br><span class="line"><span class="comment">-- while loop</span></span><br><span class="line"><span class="keyword">while</span> condition do</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure></li>
<li>Array indexing: <code>A[i]</code></li>
<li>Method call:
<code>variable.method(argument [, argument...])</code></li>
<li>Return value: <code>return expression</code></li>
<li>Example <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arrayMax(A, n)</span><br><span class="line">  Input: <span class="keyword">array</span> A <span class="keyword">of</span> n integers. <span class="keyword">Array</span> indexing starts from <span class="number">0</span></span><br><span class="line">  Output: maximum element <span class="keyword">of</span> A</span><br><span class="line"></span><br><span class="line">  res &lt;- A[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i &lt;- <span class="number">1</span> <span class="keyword">to</span> n - <span class="number">1</span> do</span><br><span class="line">    <span class="keyword">if</span> A[i] &gt; res <span class="keyword">then</span></span><br><span class="line">      res &lt;- A[i]</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Cormen-lib project
<ul>
<li>Syntax
<ul>
<li>Expressions
<ul>
<li>Standard mathematical symbols used for arithmetic and boolean
expressions</li>
<li><code>=</code> used in assigned statements</li>
<li><code>==</code> used for equality</li>
</ul></li>
<li>Control flow <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if statement</span></span><br><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">  statement</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  statement</span><br><span class="line"><span class="comment"># for loop</span></span><br><span class="line"><span class="comment"># start is inclusive, stop is exclusive</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, stop): </span><br><span class="line">  statement</span><br><span class="line"><span class="comment"># while loop</span></span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">  statement</span><br></pre></td></tr></table></figure></li>
<li>Array syntax
<ul>
<li>Instantiation: <code>A = Array(n)</code></li>
<li>Array indexing: <code>A[i]</code></li>
</ul></li>
<li>Example <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayMax</span>(<span class="params">A</span>):</span></span><br><span class="line">  <span class="comment"># Input: array A of n integers</span></span><br><span class="line">  <span class="comment"># Output: maximum element of A</span></span><br><span class="line">  res = A[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, A.length()):</span><br><span class="line">    <span class="keyword">if</span> A[i] &gt; res:</span><br><span class="line">      res = A[i]</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-03-20220124">Lecture 03 2022/01/24</h2>
<ol type="1">
<li>Theoretical analysis
<ul>
<li>General methodology
<ul>
<li>Consider all possible inputs</li>
<li>It can be performed studying high-level description of the
algorithm</li>
<li>Evaluating the relative efficiency of algorithms is independent from
hardware and software</li>
</ul></li>
<li>Assumptions
<ul>
<li>Memory is unlimited, all memory is equally expensive to access</li>
<li>Sequential execution</li>
<li>Support simple constant-time instructions</li>
<li>Support arithmetic operations, data movement and function calls</li>
<li>Memory access takes unit time</li>
</ul></li>
<li>Running time
<ul>
<li>The number of operations required to carry out a given task, it's
open referred as time complexity</li>
<li>Running time is a function as input size n</li>
</ul></li>
<li>Primitive operations
<ul>
<li>Assign a value to a variable</li>
<li>Call a method</li>
<li>Perform an arithmetic operation</li>
<li>Compare two numbers</li>
<li>Index into an array</li>
<li>Return a value</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-04-20210126">Lecture 04 2021/01/26</h2>
<ol type="1">
<li>Complexity of an algorithm depends on
<ul>
<li>Size of input</li>
<li>Other characteristics of the input data: is input sorted, is there
cycles in the graph</li>
</ul></li>
<li>Algorithm analysis
<ul>
<li>Interested aspects:
<ul>
<li>Growth rate: how the running time grows with the input size</li>
<li>Asymptotic complexity: the running time for larger inputs</li>
</ul></li>
<li>Behaviors
<ul>
<li>Worst case: maximum time required for program execution</li>
<li>Average case: average time required for program execution</li>
<li>Best case: minimum time required for program execution</li>
</ul></li>
</ul></li>
<li>Asymptotic analysis
<ul>
<li>Running time = <span class="math inline">\(f(n)\)</span></li>
<li>Consider <span class="math inline">\(\lim\limits_{n\rightarrow
\infty} \frac{f(n)}{g(n)}\)</span></li>
<li>Exact running time/ exact complexity: a concrete form of <span class="math inline">\(f(n)\)</span></li>
<li>Notation
<ul>
<li><span class="math inline">\(O(n)\)</span>: <span class="math inline">\(\exists c &gt; 0, n_0 &gt; 1: \forall n \ge n_0,
f(n) \le c * g(n)\)</span></li>
<li><span class="math inline">\(\Omega(n)\)</span>: <span class="math inline">\(\exists c &gt; 0, n_0 &gt; 1: \forall n \ge n_0,
f(n) \ge c * g(n)\)</span></li>
<li><span class="math inline">\(\Theta(n)\)</span>: <span class="math inline">\(\exists c_1 &gt; 0, c_2 &gt; 0, n_0 &gt; 1:
\forall n \ge n_0, c_1 * g(n) \le f(n) \le c_2 * g(n)\)</span></li>
</ul></li>
<li>Common orders of magnitude
<ul>
<li><span class="math inline">\(O(1)\)</span>: constant running
time</li>
<li><span class="math inline">\(O(logn)\)</span>: logarithmic running
time</li>
<li><span class="math inline">\(O(n)\)</span>: linear running time</li>
<li><span class="math inline">\(O(nlogn)\)</span>: linearithmic running
time</li>
<li><span class="math inline">\(O(n^2)\)</span>:quadratic running
time</li>
<li><span class="math inline">\(O(n^3)\)</span>: cubic running time</li>
<li><span class="math inline">\(O(n^k)\)</span>: polynomial running
time</li>
<li><span class="math inline">\(O(2^n)\)</span>: exponential running
time</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-05-20210127">Lecture 05 2021/01/27</h2>
<ol type="1">
<li>Asymptotic analysis
<ul>
<li>Properties
<ul>
<li>Transitivity:
<ul>
<li>If <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(g(n))\)</span>, and <span class="math inline">\(g(n)\)</span> is <span class="math inline">\(O(h(n))\)</span>, then <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(h(n))\)</span></li>
<li>If <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Omega(g(n))\)</span>, and <span class="math inline">\(g(n)\)</span> is <span class="math inline">\(\Omega(h(n))\)</span>, then <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Omega(h(n))\)</span></li>
<li>If <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Theta(g(n))\)</span>, and <span class="math inline">\(g(n)\)</span> is <span class="math inline">\(\Theta(h(n))\)</span>, then <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Theta(h(n))\)</span></li>
</ul></li>
<li>Reflexivity:
<ul>
<li><span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(f(n))\)</span></li>
<li><span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Omega(f(n))\)</span></li>
<li><span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Theta(f(n))\)</span></li>
</ul></li>
<li>Symmetry:
<ul>
<li><span class="math inline">\(f(n)\)</span> is <span class="math inline">\(\Theta(g(n)) \iff g(n)\)</span> is <span class="math inline">\(\Theta(f(n))\)</span></li>
</ul></li>
<li>Complementary:
<ul>
<li><span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(g(n)) \iff g(n)\)</span> is <span class="math inline">\(\Omega(f(n))\)</span></li>
</ul></li>
</ul></li>
<li>Useful Rules
<ul>
<li>If <span class="math inline">\(d(n)\)</span> is <span class="math inline">\(O(f(n))\)</span>, then <span class="math inline">\(a*d(n)\)</span> is <span class="math inline">\(O(f(n))\)</span>, for any constant a &gt; 0</li>
<li>If <span class="math inline">\(d(n)\)</span> is <span class="math inline">\(O(f(n))\)</span>, and <span class="math inline">\(e(n)\)</span> is <span class="math inline">\(O(g(n))\)</span>, then <span class="math inline">\(d(n) + e(n)\)</span> is <span class="math inline">\(O(f(n) + g(n))\)</span></li>
<li>If <span class="math inline">\(d(n)\)</span> is <span class="math inline">\(O(f(n))\)</span>, and <span class="math inline">\(e(n)\)</span> is <span class="math inline">\(O(g(n))\)</span>, then <span class="math inline">\(d(n) * e(n)\)</span> is <span class="math inline">\(O(f(n) * g(n))\)</span></li>
<li>If <span class="math inline">\(d(n)\)</span> is <span class="math inline">\(O(f(n))\)</span> and <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(g(n))\)</span>, then <span class="math inline">\(d(n)\)</span> is <span class="math inline">\(O(g(n))\)</span></li>
<li>If <span class="math inline">\(f(n)\)</span> is a polynomial of
degree d, then <span class="math inline">\(f(n)\)</span> is <span class="math inline">\(O(n^d)\)</span></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-06-20210131">Lecture 06 2021/01/31</h2>
<ol type="1">
<li>Stack
<ul>
<li>A stack is a linear data structures</li>
<li>It stores arbitrary elements according to the LIFO (last in first
out) principle</li>
<li>You can only access the top of the stack</li>
<li>Stack can be implemented using array and linked-list</li>
<li>Stack index starts from 1</li>
<li>Operations
<ul>
<li><code>push(ele)</code>: insert an element <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push (S, x):</span><br><span class="line">  if S.top_index &gt;&#x3D; n then:</span><br><span class="line">    Error: stack overflow</span><br><span class="line">  else:</span><br><span class="line">    S.top_index &lt;- S.top_index + 1</span><br><span class="line">    S[top_index] &lt;- x</span><br></pre></td></tr></table></figure></li>
<li><code>pop()</code>: remove and return the last inserted element
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop(S):</span><br><span class="line">  if stack-Empty(S) then:</span><br><span class="line">    Error: stack underflow</span><br><span class="line">  else:</span><br><span class="line">    S.top_index &lt;- S.top_index - 1</span><br><span class="line">    return S[S.top_index + 1]</span><br></pre></td></tr></table></figure></li>
<li><code>top()</code>: return the last inserted element without
removing it <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top(S)</span><br><span class="line">  if stack-Empty(S) then</span><br><span class="line">    Error: stack empty</span><br><span class="line">  return S[S.top_index]</span><br></pre></td></tr></table></figure></li>
<li><code>size()</code>: return the number of element stored
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(S)</span><br><span class="line">  return S.top_index</span><br></pre></td></tr></table></figure></li>
<li><code>isEmpty()</code>: indicate whether no elements are stored
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack-Empty(S)</span><br><span class="line">  if S.top_index &#x3D;&#x3D; 0 then</span><br><span class="line">    return true</span><br><span class="line">  else</span><br><span class="line">    return false</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Performance
<ul>
<li>Space used: <span class="math inline">\(O(n)\)</span></li>
<li>Each operation runs in time: <span class="math inline">\(O(1)\)</span></li>
</ul></li>
</ul></li>
<li>Queues
<ul>
<li>A queue is a linear data structure</li>
<li>It stores arbitrary elements according to the FIFO (first in first
out) principle</li>
<li>You can insert an the end of the queue, and remove from the front of
the queue</li>
<li>Queue can be implemented using array and linked-lists</li>
<li>Queue index starts from 1</li>
<li>Queue implementation choice
<ul>
<li>Let index 1 be the front of the queue: not a good choice, each
dequeue operation involves shifting the remaining elements, which is
linear complexity</li>
<li>Use <code>front_index</code>(the current head element) and
<code>rear_index</code> (<code>rear_index - 1</code> is the current rear
element): the pointers need to be wrapped around after reaching the end
of the array, which results in a circular queue. &gt; For an array
indexing from 1 to n, there can be at most n - 1 elements in the
circular queue</li>
</ul></li>
<li>Operations
<ul>
<li><code>enqueue(ele)</code>: insert an element at the end of the queue
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enqueue(Q, x)</span><br><span class="line"> if size(Q) &#x3D; n then</span><br><span class="line">  Error: queue overflow</span><br><span class="line">else</span><br><span class="line">  Q[Q.read_index] &#x3D; x</span><br><span class="line">  Q.read_index &lt; - Q.read_index % n + 1</span><br></pre></td></tr></table></figure></li>
<li><code>dequeue()</code>: remove and return the element at the front
of the queue <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dequeue(Q):</span><br><span class="line">  if isEmpty(Q) then</span><br><span class="line">    Error: queue underflow</span><br><span class="line">  else</span><br><span class="line">    x &lt;- Q[Q.front_index]</span><br><span class="line">    Q.front_index &lt;- Q.front_index % n + 1</span><br><span class="line">    return x</span><br></pre></td></tr></table></figure></li>
<li><code>size()</code>: return the number of element stored
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(Q)</span><br><span class="line">  return (n + Q.rear_index - Q.front_index) % n</span><br></pre></td></tr></table></figure></li>
<li><code>isEmpty()</code>: indicate whether no elements are stored
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isEmpty(Q)</span><br><span class="line">  if Q.front_index &#x3D; Q.rear_index then</span><br><span class="line">    return true</span><br><span class="line">  else</span><br><span class="line">    return false</span><br></pre></td></tr></table></figure></li>
<li><code>rear()</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rear(Q)</span><br><span class="line">  if isEmpty(Q) then</span><br><span class="line">    Error: queue empty</span><br><span class="line">  else</span><br><span class="line">    if Q.rear_index &#x3D; 1 then</span><br><span class="line">      return Q[n]</span><br><span class="line">    else</span><br><span class="line">      return Q[Q.rear_index - 1]</span><br></pre></td></tr></table></figure></li>
<li><code>front()</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">front(Q)</span><br><span class="line">  if isEmpty(Q) then</span><br><span class="line">    Error: queue empty</span><br><span class="line">  else</span><br><span class="line">    return Q[Q.front_index]</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Search in queue: <span class="math inline">\(O(n)\)</span></li>
</ul></li>
</ol>
<h2 id="lecture-07-20220202">Lecture 07 2022/02/02</h2>
<ol type="1">
<li>Examples
<ul>
<li>Evaluating postfix</li>
<li>Parentheses matching</li>
<li>Reverse an array</li>
<li>Separate an array</li>
</ul></li>
<li>Array limitation
<ul>
<li>Fixed size</li>
<li>Physically stored in consecutive memory locations</li>
<li>To insert or delete items, may need to shift data</li>
</ul></li>
<li>Time complexity analysis
<ul>
<li>Linear search: <span class="math inline">\(O(n)\)</span></li>
<li>Binary search: the array needs to be sorted, <span class="math inline">\(O(logn)\)</span></li>
<li>Bubble sort: <span class="math inline">\(O(n^2)\)</span></li>
</ul></li>
</ol>
<h2 id="lecture-08-20220203">Lecture 08 2022/02/03</h2>
<ol type="1">
<li>Introduction
<ul>
<li>Array limitations
<ul>
<li>Fixed size</li>
<li>Physically stored in consecutive memory locations</li>
<li>To insert or delete items, may need to shift data</li>
</ul></li>
<li>A linked data structure consists of items that are linked to other
items</li>
<li>Advantages
<ul>
<li>Items do not have to be stored in consecutive memory locations</li>
<li>Linked lists can grow dynamically</li>
</ul></li>
</ul></li>
<li>Linked list
<ul>
<li>A linked list L (or head) is a linear data structure consisting of
nodes</li>
<li>Linear or der of linked list is determined by a link to the next
node</li>
<li>A node consists of two fields
<ul>
<li>A data portion (called key or data), it should be generic</li>
<li>A link (or pointer) to the next node in the structure</li>
</ul></li>
<li><code>x.next</code> points to the successor of node x</li>
<li><code>x.next = NIL</code> indicates that x is the last node in the
linked list</li>
<li>Singly linked list
<ul>
<li>It has one lik per node, which points to the next node in the
list</li>
<li>The list has a link to the first node called L (or head),
<code>L = NIL</code> indicates the list is empty</li>
<li>The list may or may not have a tail</li>
</ul></li>
<li>Link hopping: traversing the linked list by moving from one node to
another via following the link next</li>
<li><code>x.next = p</code>: node p is the successor of node x</li>
<li><code>p.next = x</code>: node p is the predecessor of node x</li>
<li>The length of a linked list is the number of nodes in the list</li>
<li>Operations on linked list: isEmpty, insertNode, findNode,
deleteNode, displayList</li>
<li>Search in a linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Linear time complexity</span><br><span class="line">search(L, x)</span><br><span class="line">  cur &lt;- L</span><br><span class="line">  while cur !&#x3D; NIL and cur.key !&#x3D; x do</span><br><span class="line">    cur &lt;- cur.next</span><br><span class="line">  return cur</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-09-20220207">Lecture 09 2022/02/07</h2>
<ol type="1">
<li>Linked list operations
<ul>
<li>Insert a node in the linked list
<ul>
<li>Insert a node in an empty linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">insertEmpty(L, x)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &#x3D; x</span><br><span class="line">  p.next &#x3D; NIL</span><br><span class="line">  L &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
<li>Insert a node at the beginning of a linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">insertFirst(L, x)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &#x3D; x</span><br><span class="line">  p.next &lt;- L</span><br><span class="line">  L &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
<li>Insert a node at the end of a linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># If we do not have a tail pointer</span><br><span class="line"># Linear time complexity</span><br><span class="line">insertLast(L, x)</span><br><span class="line">  cur &lt;&#x3D; L</span><br><span class="line">  while cur.next !&#x3D; NIL do</span><br><span class="line">    cur &lt;- cur.next</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &#x3D; x</span><br><span class="line">  p.next &lt;- NIL</span><br><span class="line">  cur.next &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br><span class="line"></span><br><span class="line"># If we have a tail pointer</span><br><span class="line"># Constant time complexity</span><br><span class="line">insertLast(L, tail, x)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &lt;- x</span><br><span class="line">  p.next &lt;- NIL</span><br><span class="line">  tail.next &lt;- p</span><br><span class="line">  tail &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
<li>Insert a node after a given node <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">insertAfter(L, x, curNode)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &lt;- x</span><br><span class="line">  p.next &lt;- curNode.next</span><br><span class="line">  curNode.next &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Delete a node
<ul>
<li>Delete the first node <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">deleteFirst(L)</span><br><span class="line">  if L &#x3D;&#x3D; NIL then</span><br><span class="line">    Error: Linked list is empty</span><br><span class="line">  L &lt;- L.next</span><br><span class="line">  size &lt;- size - 1</span><br></pre></td></tr></table></figure></li>
<li>Delete the last node <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Linear time complexity</span><br><span class="line">deleteLast(L)</span><br><span class="line">  if L &#x3D; NIL then</span><br><span class="line">    Error: Linked list is empty</span><br><span class="line">  if L.next &#x3D; NIL then</span><br><span class="line">    L &lt;- NIL</span><br><span class="line">  cur &lt;- L</span><br><span class="line">  while cur.next !&#x3D; NIL and cur.next.next !&#x3D; NIL do</span><br><span class="line">    cur &lt;- cur.next</span><br><span class="line">  cur.next &#x3D; NIL</span><br><span class="line">  size &lt;- size - 1</span><br></pre></td></tr></table></figure></li>
<li>Delete a node in the middle <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">deleteMiddle(L, prev, curr)</span><br><span class="line">  prev.next &lt;- curr.next</span><br><span class="line">  size &lt;- size - 1</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Reverse a linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Iterative approach</span><br><span class="line">reverseLink(L)</span><br><span class="line">  if L &#x3D;&#x3D; NIL or L.next &#x3D;&#x3D; NIL then</span><br><span class="line">    return L</span><br><span class="line">  prv &lt;- NIL</span><br><span class="line">  cur &lt;- L</span><br><span class="line">  while cur !&#x3D; NIL do</span><br><span class="line">    nxt &lt;- cur.next</span><br><span class="line">    cur.next &lt;- prv</span><br><span class="line">    prv&lt;- cur</span><br><span class="line">    cur &lt;- nxt</span><br><span class="line">  return prv</span><br><span class="line"></span><br><span class="line"># Recursive approach</span><br><span class="line">reverseLink(L)</span><br><span class="line">  if L &#x3D;&#x3D; NIL or L.next &#x3D;&#x3D; NIL then</span><br><span class="line">    return L</span><br><span class="line">  # the function reverseLink(p) reverse the linked list starting from</span><br><span class="line">  # node p, and return the new head of the reversed linked list</span><br><span class="line">  p &lt;- reverseLink(L.next)</span><br><span class="line">  # L.next is the tail of the reversed list, so put L as the new tail</span><br><span class="line">  L.next.next &lt;- L</span><br><span class="line">  L.next &lt;- NIL</span><br><span class="line">  return p</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-10-20220209">Lecture 10 2022/02/09</h2>
<ol type="1">
<li>Static v.s. dynamic data structures
<ul>
<li>Static data structure such arrays allow
<ul>
<li>Fast access to elements</li>
<li>Expensive to insert/remove elements</li>
<li>Have fixed, maximum size</li>
</ul></li>
<li>Dynamic data structure such ass linked list allow
<ul>
<li>Fast insertion/deletion of elements, no need to move other nodes,
only need to reset some pointers</li>
<li>Slower access to elements, do not keep track of any index for the
nodes</li>
<li>Can easily grow and shrink in size</li>
</ul></li>
</ul></li>
<li>Linked list implemented stack and queue
<ul>
<li>Stack: space is <span class="math inline">\(O(n)\)</span>, each
operation is <span class="math inline">\(O(1)\)</span>
<ul>
<li><code>top()</code>, <code>push()</code>, <code>pop()</code></li>
</ul></li>
<li>Queue: space is <span class="math inline">\(O(n)\)</span>, each
operation is <span class="math inline">\(O(1)\)</span>
<ul>
<li><code>front()</code>, <code>rear()</code>, <code>enqueue()</code>,
<code>dequeue()</code></li>
</ul></li>
</ul></li>
<li>Variations of linked list
<ul>
<li>Doubly linked list</li>
<li>Circular linked list</li>
<li>Sorted linked list</li>
</ul></li>
<li>Doubly linked list
<ul>
<li>Node
<ul>
<li><code>x.data</code>, <code>d.next</code>, <code>x.prev</code></li>
<li><code>x.prev = NIL</code>, then x is the first element</li>
<li><code>x.next = NIL</code>, then x is the last element</li>
<li><code>head</code> points to the first element in the list</li>
<li><code>head = NIL</code>, then the list is empty</li>
</ul></li>
<li>Insert at the front of a doubly linked list <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">insertFirst(L, x)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &lt;- x</span><br><span class="line">  p.prev &lt;- NIL</span><br><span class="line">  p.next &lt;- L</span><br><span class="line">  if L !&#x3D; NIL then </span><br><span class="line">    L.prev &lt;- p</span><br><span class="line">  L &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
<li>Insert after a node <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">insertAfter(L, x, cur)</span><br><span class="line">  p &lt;- newNode()</span><br><span class="line">  p.key &lt;- x</span><br><span class="line">  p.prev &lt;- cur</span><br><span class="line">  p.next &lt;- cur.next</span><br><span class="line">  if cur.next !&#x3D; NIL then</span><br><span class="line">    cur.next.prev &lt;- p</span><br><span class="line">  cur.next &lt;- p</span><br><span class="line">  size &lt;- size + 1</span><br></pre></td></tr></table></figure></li>
<li>Delete a node <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Constant time complexity</span><br><span class="line">deleteNode(L, cur)</span><br><span class="line">  if L &#x3D; NIL or cur &#x3D; NIL then</span><br><span class="line">    Error: Cannot delete</span><br><span class="line">  if cur.prev &#x3D; NIL then</span><br><span class="line">    L &lt;- cur.next</span><br><span class="line">  else</span><br><span class="line">    cur.prev.next &lt;- cur.next</span><br><span class="line">  if cur.next !&#x3D; NIL then</span><br><span class="line">    cur.next.prev &lt;- cur.prev</span><br><span class="line">  size &lt;- size - 1</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-11-20220210">Lecture 11 2022/02/10</h2>
<ol type="1">
<li>Introduction
<ul>
<li>Recursion is a problem solving approach where the solution of a
problem depends on solutions to smaller instances of the same
problem</li>
<li>Recursion uses the divide-and-conquer technique</li>
</ul></li>
<li>Recursion problems
<ul>
<li>A recursive description of a problem is one where
<ul>
<li>A problem can be broken into smaller parts</li>
<li>Each part is a smaller version of the original problem</li>
<li>There is a base case that can be solved immediately</li>
</ul></li>
<li>A recursive algorithm has at least two cases
<ul>
<li>Base case</li>
<li>Recursive case</li>
</ul></li>
<li>Tail recursion: when recursion involves single call that is at the
end it is called tail recursion and is easy to make iterative</li>
<li>Cost of recursion: call a function consumes more time and memory
than adjusting a loop counter, thus high performance applications hardly
ever use recursion</li>
</ul></li>
</ol>
<h2 id="lecture-12-20220214">Lecture 12 2022/02/14</h2>
<ol type="1">
<li>Analysis of recursive algorithm
<ul>
<li>Recursive mathematical equations are called recurrence equations/
recurrence relations, or simply recurrence</li>
<li>We use recurrence relation to analyze recursive algorithm</li>
<li>Recurrence relation, <span class="math inline">\(T(n)\)</span>, is
an equation which is defined in terms of itself <span class="math display">\[
T(n) =     \begin{cases}
c &amp; \text{if n = 0 base case}\\
a*T(n) + b &amp; \text{if n &gt; 0 recursive case}\\
\end{cases}
\]</span>
<ul>
<li>a is the number of sub-problems</li>
<li>m is the size of the sub-problems</li>
<li>b is the time to divide into sub-problems and combine the
solution</li>
</ul></li>
<li>Examples
<ul>
<li>Example 1 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo(n)</span><br><span class="line">  if n &#x3D; 0 then </span><br><span class="line">    return 2</span><br><span class="line">  else</span><br><span class="line">    return Foo(n - 1) + 5</span><br></pre></td></tr></table></figure> <span class="math display">\[
T(n) =
\begin{cases}
   c &amp; \text{if n = 1} \\
   T(n - 1) + b &amp; \text{if n &gt; 1}
\end{cases}
\]</span></li>
<li>Example 2 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo(n)</span><br><span class="line">  if n &#x3D; 1 then </span><br><span class="line">    return 1</span><br><span class="line">  else</span><br><span class="line">    return Foo(n &#x2F; 2) + Foo (n &#x2F; 2) + 5</span><br></pre></td></tr></table></figure> <span class="math display">\[
T(n) =
\begin{cases}
  c &amp; \text{if n = 1}\\
  2 * T (n / 2) + b &amp; \text{if n &gt; 1}
   \end{cases}
\]</span></li>
<li>Example 3 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo(n)</span><br><span class="line">  if n &#x3D; 1 then</span><br><span class="line">    return 1</span><br><span class="line">  else</span><br><span class="line">    return Foo(n - 1) + Foo(n &#x2F; 2) + 5</span><br></pre></td></tr></table></figure> <span class="math display">\[
T(n) =
\begin{cases}
c &amp;  \text{if n = 1} \\
T(n - 1) + T(n/2) + b &amp; \text{if n &gt; 1}
\end{cases}
\]</span></li>
</ul></li>
</ul></li>
<li>Solving recurrence relations
<ul>
<li>Example 1 <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 0}\\ b + T(n-1) &amp;
\text{else }\end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = n * b + 1\)</span>, so <span class="math inline">\(T(n)\)</span> is linear complexity</li>
</ul></li>
<li>Example 2 <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 0 or n = 1}\\ T(n - 1)
+  T(n-1) &amp; \text{else }\end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n)\)</span> is exponential
complexity</li>
</ul></li>
<li>Improved Fibonnacci <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Linear time complexity</span><br><span class="line">improvedFibonnacci(n)</span><br><span class="line">  a &lt;- Array(n + 1)</span><br><span class="line">  a[0] &lt;- 1</span><br><span class="line">  a[1] &lt;- 1</span><br><span class="line">  for i &lt;- 2 to n do</span><br><span class="line">    a[i] &lt;- a[i - 1] + a[i - 2]</span><br><span class="line">  return a[n]</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-13-20220216">Lecture 13 2022/02/16</h2>
<ol type="1">
<li>Solving recurrence relation
<ul>
<li>Example 1 <span class="math display">\[
T(n) = \begin{cases} c &amp; \text{if n = 1} \\ 2 * T(n/2) + b &amp;
\text{if n &gt; 1}\end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = c + (n - 1) * b\)</span>, so
<span class="math inline">\(T(n)\)</span> is linear complexity</li>
</ul></li>
<li>Example 2 <span class="math display">\[
T(n) = \begin{cases} c &amp; \text{if n = 1} \\ T(n - 1) + n + b &amp;
\text{if n &gt; 1}\end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = c + n * (n + 1) / 2 - 1 + n * (n
- 1)\)</span>, so <span class="math inline">\(T(n)\)</span> is quadratic
complexity</li>
</ul></li>
<li>Example 3: Binary search recursively <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Logarithmic time complexity</span><br><span class="line">binarySearch(a, target, low, high)</span><br><span class="line">  if low &gt; high then</span><br><span class="line">    return - 1</span><br><span class="line">  mid &lt;- low + (high - low) &#x2F; 2</span><br><span class="line">  if (a[mid] &#x3D; target) then</span><br><span class="line">    return mid</span><br><span class="line">  else if (a[mid] &gt; target) then</span><br><span class="line">    return binarySearch(a, target, low, mid - 1)</span><br><span class="line">  else</span><br><span class="line">    return binarySearch(a, target, mid + 1, high)</span><br></pre></td></tr></table></figure> <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 1}\\ T(n/2) + b &amp; \text{if
n &gt; 1} \end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = 1 + log_2{n}\)</span>, so <span class="math inline">\(T(n)\)</span> is logarithmic complexity</li>
</ul></li>
<li>Example 4 <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 1}\\ 2* T(n - 1) + 1 &amp;
\text{if n &gt; 1} \end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = 2^n - 1\)</span>, so <span class="math inline">\(T(n)\)</span> is exponential complexity</li>
</ul></li>
<li>Example 5 <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 1}\\ T(n / 2) + n &amp;
\text{if n &gt; 1} \end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = 1 + ... + n/4 + n/2 + n =
\sum\limits_{i = 0} ^{log_2{n}} n * (1/2) ^{i} = 2 * n - 1\)</span>, so
<span class="math inline">\(T(n)\)</span> is linear complexity</li>
</ul></li>
<li>Example 6 <span class="math display">\[
T(n) = \begin{cases} 1 &amp; \text{if n = 1}\\ 2 * T(n / 2) + c * n
&amp; \text{if n &gt; 1} \end{cases}
\]</span>
<ul>
<li><span class="math inline">\(T(n) = 2^{k} T(n/{2^{k}}) + c* k *n = n
+ c * log_2{n} * n\)</span>, so <span class="math inline">\(T(n)\)</span> is linearithmic complexity</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-14-20220217">Lecture 14 2022/02/17</h2>
<ol type="1">
<li>Introduction
<ul>
<li>A tree is a non-linear data structure that follows the shape of a
tree</li>
<li>A tree stores elements hierarchically</li>
<li>Formal definition: a tree T is a set of nodes storing elements, the
nodes have a parent-child relationship, that satisfies the following
properties
<ul>
<li>If I is nonempty, it has a special node called the root of T, the
root has no parents</li>
<li>Every node v of T, different from the root has a unique parent node
w, every node with parent w is a child of w</li>
</ul></li>
<li>Terminology
<ul>
<li>Each node (except the root) has exactly one node above it, called
parent</li>
<li>The nodes directly below a node are called children</li>
<li>Root is the topmost node without parent</li>
<li>Internal node: node with at least one child</li>
<li>External node (leaf): node without children</li>
<li>Siblings: nodes that are children of the same parent</li>
<li>Ancestors: parent, grandparent, grand-grandparent, etc.</li>
<li>Descendent: child, grandchild, grand-grandchild, etc.</li>
<li>Subtree: of T rooted at a node v: tree consisting of all the
descendent of v in Tincluding v itself</li>
<li>Edge: pair of nodes (u, v) such that u is a parent of v, or vice
versa</li>
<li>Path: sequence of nodes such that any two consecutive nodes in the
sequence form an edge</li>
</ul></li>
<li>Tree representation: LMCHILD-RSIB representation
<ul>
<li>Node
<ul>
<li>data, parent pointer, leftmost child pointer, right sibling
pointer</li>
</ul></li>
<li>Tree abstract data type (ADT)
<ul>
<li><code>data(v, T)</code>: return the data stored at the node v</li>
<li><code>root(T)</code>: return the tree's root, an error occur if the
tree is empty</li>
<li><code>parent(v, T)</code>: return the parent of v, an error occur if
v is the root</li>
<li><code>lmchild(v, T)</code>: return the leftmost child of v</li>
<li><code>rsib(v, T)</code>: return the right sibling of v</li>
<li><code>isInternal(v, T)</code>: test whether node v is internal</li>
<li><code>isExternal(v, T)</code>: test whether node v is external</li>
<li><code>isRoot(v, T)</code>: test whether node v is the root</li>
<li><code>size(T)</code>: return the number of nodes in the tree</li>
<li><code>isEmpty(T)</code>: test whether the tree has any node or
not</li>
</ul></li>
<li>N-ary tree
<ul>
<li>If each node can have at most n children appearing in a specific
order, then we have an N-ary tree</li>
<li>The simplest type of N-ary tree is a binary tree</li>
</ul></li>
</ul></li>
</ul></li>
<li>Binary tree
<ul>
<li>Definition: a binary tree is an ordered tree with the following
properties
<ul>
<li>Each internal node has at most two children</li>
<li>Each child node is labeled as being either a left child or a right
child</li>
<li>A left child precedes a right child in the ordering of children of a
node</li>
</ul></li>
<li>Recursive definition: a binary tree is either empty or consist of:
<ul>
<li>A node r, called root of T</li>
<li>A binary tree, called the left subtree of T</li>
<li>A binary tree, called the right subtree of T</li>
</ul></li>
<li>Node in a parent tree
<ul>
<li>Element (data)</li>
<li>Parent node</li>
<li>Left child node</li>
<li>Right child node</li>
</ul></li>
<li>Binary tree ADT
<ul>
<li><code>left(v)</code>: return the left child of v, an error occur if
v has no left child</li>
<li><code>right(v)</code>: return the right child of v, an error occur
if v has no right child</li>
<li><code>parent(v)</code>: return the parent of v, an error occur if v
is the root</li>
<li><code>hasLeft(v)</code>, <code>hasRight(v)</code>: test whether v
has a left child/ a right child</li>
<li><code>addRoot(e)</code>: create a new node r storing element e and
make r the root of the T, an error occur if the tree is not empty</li>
<li><code>insertLeft(v, e)</code>: create a new node w storing element
e, add w as the left child of v, an error occur if v already has a left
child</li>
<li><code>insertRight(v, e)</code>: create a new node z storing element
e, add z as the right child of v, an error occur if v already has a
right child</li>
<li><code>remove(v)</code>: remote node v, replace it with its child, if
any, and return the element stored at v, an error occur if v has two
children</li>
<li><code>attach(v, T1, T2)</code>: attach T1 and T2, respectively, as
left and right subtree of the external node v, an error occur if v is
internal</li>
</ul></li>
</ul></li>
<li>Tree traversal algorithm
<ul>
<li>A traversal of a tree T is a systematic way of accessing (or
visiting) all the nodes of T</li>
<li>Pre-order: visit the node, then visit the left subtree, and then
visit the right subtree <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">preOrder(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  visit(v);</span><br><span class="line">  preOrder(v.left);</span><br><span class="line">  preOrder(v.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>N-ary tree pre-order <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(T, v) &#123;</span><br><span class="line">  visit(v);</span><br><span class="line">  <span class="keyword">for</span> (w: v.children) &#123;</span><br><span class="line">    preOrder(T, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-15-20220228">Lecture 15 2022/02/28</h2>
<ol type="1">
<li>Tree traversal algorithm
<ul>
<li>Post-order visit the left subtree, then visit the right subtree,
and then visit the node <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postOrder(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  postOrder(v.left);</span><br><span class="line">  postOrder(v.right);</span><br><span class="line">  visit(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>N-ary tree post-order <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(T, v) &#123;</span><br><span class="line">  <span class="keyword">for</span> (w: v.children) &#123;</span><br><span class="line">    postOrder(T, w);</span><br><span class="line">  &#125;</span><br><span class="line">  visit(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>In-order: visit the left subtree, then visit the node, then visit
the right subtree <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inOrder(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(v.left);</span><br><span class="line">  visit(v);</span><br><span class="line">  inOrder(v.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Level-order traversal <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">levelOrder(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue q = <span class="keyword">new</span> Queue();</span><br><span class="line">  <span class="keyword">while</span> q.size() != <span class="number">0</span>:</span><br><span class="line">    front = q.dequeue();</span><br><span class="line">    visit(front);</span><br><span class="line">    <span class="keyword">for</span> (w: front.children) &#123;</span><br><span class="line">      q.eneueue(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Height of a tree
<ul>
<li>Definition: the height of a tree is number of edges on the longest
path from the root to a leaf</li>
<li>Height of a node: the number of edges on the longest path from the
node to a leaf</li>
</ul></li>
</ol>
<h2 id="lecture-16-20220302">Lecture 16 2022/03/02</h2>
<ol type="1">
<li>Height of a tree
<ul>
<li>Height of a node v: the number of edges on the longest path from the
node v to a leaf <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">height(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + Math.max(height(v.left), height(v.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Depth of a node v: the number of edges on the path from the root to
the node v <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">depth(T, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == T.root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + depth(T, v.parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Binary search tree (BST)
<ul>
<li>Definition: a BST is a binary tree where the data are always stored
in such a way that they satisfy the binary search tree property</li>
<li>BST property: for every node v, all keys in its left subtree are
smaller than or equal to the key of v, and all keys in its right subtree
are larger than or equal to the key of v</li>
<li>BST representation
<ul>
<li>Node: data, parent, left, child</li>
<li>Root: <code>parent=NIL</code></li>
</ul></li>
<li>Searching <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(v, key) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span> || v.data == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; v.data) &#123;</span><br><span class="line">    <span class="keyword">return</span> search(v.left, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> search(v.right, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Full tree and complete tree
<ul>
<li>Full: a binary tree is full if each node has either 0 or 2 children
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">isFull(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v.left == <span class="keyword">null</span> &amp;&amp; v.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v.left != <span class="keyword">null</span> &amp;&amp; v.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> isFull(v.left) &amp;&amp; isFull(v.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Complete: a binary with n levels is complete if every level is
completely filled except possibly the last level, which is filled from
left to right <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">isComplete(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue q = <span class="keyword">new</span> Queue();</span><br><span class="line">  q.enqueue(v);</span><br><span class="line">  flag = <span class="keyword">false</span></span><br><span class="line">  <span class="keyword">while</span> (q.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    n = q.size();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      front = q.dequeue();</span><br><span class="line">      <span class="comment">// If we meet a null in a level, mark the flag as true</span></span><br><span class="line">      <span class="keyword">if</span> (front == <span class="keyword">null</span>) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If we met a null before, but now we are at a non-null node, return false</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.enqueue(front.left);</span><br><span class="line">        q.enqueue(front.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-17-20220303">Lecture 17 2022/03/03</h2>
<ol type="1">
<li>Properties of binary trees
<ul>
<li>Suppose a binary tree has n nodes, and its height is h, then
<ul>
<li><span class="math inline">\(h + 1 \le n \le 2^{h + 1} -
1\)</span></li>
<li><span class="math inline">\(log(n + 1) - 1 \le h \le n -
1\)</span></li>
</ul></li>
</ul></li>
<li>BST operations
<ul>
<li>Searching <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(v, key) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span> || v.data == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; v.data) &#123;</span><br><span class="line">    <span class="keyword">return</span> search(v.left, key);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> search(v.right, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Minimum <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">minimum(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (v.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    v = v.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Maximum <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maximum(v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (v.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      v = v.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Successor <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">successor(v) &#123;</span><br><span class="line">  <span class="comment">// If v has right subtree, then the successor is the leftmost one in the right subtree</span></span><br><span class="line">  <span class="keyword">if</span> (v.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> minimum(v.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If v does not have a right subtree, find a node x such that v is the largest one </span></span><br><span class="line">  <span class="comment">// on the left subtree of x, x is null when v is the largest one in the tree</span></span><br><span class="line">  <span class="keyword">while</span> (v.parent != <span class="keyword">null</span> &amp;&amp; v.parent.right == v) &#123;</span><br><span class="line">    v = v.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v.parent;  <span class="comment">// v.parent could be null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Predecessor <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">predecessor(v) &#123;</span><br><span class="line">  <span class="comment">// If v has left subtree, the the predecessor is the rightmost one in the left subtree</span></span><br><span class="line">  <span class="keyword">if</span> (v.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> maximum(v.left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If v does not have a left subtree, find a node x such that v is the smallest one </span></span><br><span class="line">  <span class="comment">// on the right subtree of x, x is null when v is the smallest one in the tree</span></span><br><span class="line">  <span class="keyword">while</span> (v.parent != <span class="keyword">null</span> &amp;&amp; v.parent.left == v) &#123;</span><br><span class="line">    v = v.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v.parent; <span class="comment">// v.parent could be null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Insertion-recursive approach: return the root of the tree
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      root = node;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (root.data &gt; node.data) &#123;</span><br><span class="line">      TreeNode left = insert(root.left, node);</span><br><span class="line">      root.left = left;</span><br><span class="line">      left.parent  = root;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.data &lt; node.data) &#123;</span><br><span class="line">      TreeNode right = insert(root.right, node);</span><br><span class="line">      root.right = right;</span><br><span class="line">      right.parent = root;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Insertion-iterative approach: return the root of the tree
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterative</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">insert</span><span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">   TreeNode prev = <span class="keyword">null</span>;   <span class="comment">// prev is the parent of the inserted node</span></span><br><span class="line">   TreeNode cur = root;   <span class="comment">// cur is where node should be inserted</span></span><br><span class="line">   <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prev = cur;</span><br><span class="line">      <span class="keyword">if</span> (cur.data &gt; node.data) &#123;</span><br><span class="line">         cur = cur.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         cur = cur.right;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   node.parent = prev;</span><br><span class="line">   <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;  <span class="comment">// root is null, empty tree</span></span><br><span class="line">      root = node;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev.data &gt; node.data) &#123;</span><br><span class="line">         prev.left = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         prev.right = node;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-18-20220307">Lecture 18 2022/03/07</h2>
<ol type="1">
<li>BST operations
<ul>
<li><p>Deletion:</p>
<ul>
<li>Cases
<ul>
<li>No child: if the node has no children(leaf node), then remove it and
update parent's child pointer</li>
<li>One child: delete the node and update its parent's child pointer to
the child of the deleted node</li>
<li>Two child: swap the data of the node with its successor, then delete
the successor, the successor should have either one child or no
child</li>
</ul></li>
</ul></li>
<li><p>Deletion-recursive approach <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">delete</span> <span class="params">(TreeNode root, TreeNode node)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (root.data &lt; node.data) &#123;</span><br><span class="line">      TreeNode right = delete(root.right, node);</span><br><span class="line">      root.right = right;</span><br><span class="line">      <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">         right.parent = root;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.data &gt; node.data) &#123;</span><br><span class="line">      TreeNode left = delete(root.left, node);</span><br><span class="line">      root.left = left;</span><br><span class="line">      <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">         left.parent = root;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> root.right;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode successor = minimum(root.right);</span><br><span class="line">      root.data = successor.data;</span><br><span class="line">      root.right = delete(root.right, successor);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Deletion-iterative approach <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">delete(T, z) &#123;</span><br><span class="line">  <span class="keyword">if</span> (z.left == <span class="keyword">null</span> || z.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node y = z;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node y = successor(z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Node x = y.left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Node x = y.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">    x.parent = y.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    T.root = x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == y.parent.left) &#123;</span><br><span class="line">      y.parent.left = x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      y.parent.right = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (y != z) &#123;</span><br><span class="line">    z.data = y.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Performance evaluation</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Operation</th>
<th style="text-align: center;">Average</th>
<th style="text-align: center;">Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Search</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Insert</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Delete</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>Performance can be improved using a balanced BST (BBST)</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Operation</th>
<th style="text-align: center;">Average</th>
<th style="text-align: center;">Worst</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Search</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Insert</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Delete</td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O(logn)\)</span></td>
</tr>
</tbody>
</table></li>
</ul></li>
<li>Balanced BST (BBST)
<ul>
<li>Definition
<ul>
<li>A tree is perfectly balanced if the left and right subtree of any
node are of the same height</li>
<li>A tree is balanced if the heights of the left and right subtree of
each node are within 1 (-1, 1, 0)</li>
</ul></li>
<li>Check if a binary tree is balanced <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isBalanced(v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Math.abs(height(v.left) - height(v.right)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isBalanced(v.left) &amp;&amp; isBalanced(v.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>If you insert a node or delete a node in the BBST, the tree may be
not balanced, so you need to perform rotations to rebalance the
tree</li>
</ul></li>
<li>BST rotation
<ul>
<li>Outside cases: single rotation
<ul>
<li>Single right rotation
<ul>
<li>Idea: after inserting into the subtree X, the tree becomes
imbalanced at node j. You can do a single right rotation at node j to
rebalance the tree. In the result tree, j will take the place of i <img src="/images/Courses/COSI21A/right_rotation.png"></li>
<li>Algorithm <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rotateRight(T, v) &#123;</span><br><span class="line">  <span class="comment">// T: a BST tree</span></span><br><span class="line">  <span class="comment">// v: the node to be rotated</span></span><br><span class="line">  Node y = v.left; <span class="comment">// y cannot be null</span></span><br><span class="line">  v.left = y.right;</span><br><span class="line">  <span class="keyword">if</span> (y.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    y.right.parent = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    T.root = y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == v.parent.left) &#123;</span><br><span class="line">      v.parent.left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      v.parent.right = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  y.right = v;</span><br><span class="line">  v.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Single right rotation
<!-- Note: HTML said "Single right rotation" again, likely a typo for "Single left rotation" -->
<ul>
<li>Idea: after inserting into the subtree X, the tree becomes
imbalanced at node j. You can do a single left rotation at node j to
rebalance the tree. In the result tree, j will take the place if i <img src="/images/Courses/COSI21A/left_rotation.png"></li>
<li>Algorithm <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rotateLeft(T, v) &#123; <span class="comment">// Renamed from rotateRight for clarity</span></span><br><span class="line">  <span class="comment">// T: a BST tree</span></span><br><span class="line">  <span class="comment">// v: the node to be rotated</span></span><br><span class="line">  Node y = v.right; <span class="comment">// y cannot be null</span></span><br><span class="line">  v.right = y.left;</span><br><span class="line">  <span class="keyword">if</span> (y.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    y.left.parent = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    T.root = y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v == v.parent.left) &#123;</span><br><span class="line">      v.parent.left = y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      v.parent.right = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  y.left = v;</span><br><span class="line">  v.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-19-20220309">Lecture 19 2022/03/09</h2>
<ol type="1">
<li>BST rotation
<ul>
<li>Inside cases: double rotation
<ul>
<li>Left-right rotation
<ul>
<li>Idea: after inserting into the subtree Y, the tree becomes
imbalanced at i. You first split subtree Y into two subtrees with each
has height h, then do left rotation at node j, and then do right
rotation at node i <img src="/images/Courses/COSI21A/left_right_rotation.png"></li>
</ul></li>
<li>Right-left rotation
<ul>
<li>Idea: after inserting into the subtree Y, the tree becomes
imbalanced at i. You first split subtree Y into two subtrees with each
has height h, then do left rotation at node j, and then do left rotation
at node i <img src="/images/Courses/COSI21A/right_left_rotation.png"></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-20-20220310">Lecture 20 2022/03/10</h2>
<ol type="1">
<li>AVL trees
<ul>
<li>Discovered in 1962 by two Russian mathematicians</li>
<li>Properties
<ul>
<li>BST</li>
<li>For every node in the tree the height of the left and right subtree
differ by at most 1</li>
</ul></li>
<li>Algorithm
<ul>
<li>Search, insert, and delete as in a BST</li>
<li>After each insertion/deletion: if height of left and right subtree
differ by more than 1, restore AVL property</li>
</ul></li>
<li>Balance factor
<ul>
<li>An AVL tree has balance factor calculated at every node
<ul>
<li>BF(node) = height(node.left) - height(node.right)</li>
<li>If BF(root) &gt; 0, then the tree if left heavy</li>
<li>If BF(root) &lt; 0, then the tree is right heavy</li>
<li>If abs(BF(root)) &gt;= 2, then we should do rotations to restore AVL
property</li>
</ul></li>
</ul></li>
</ul></li>
<li>AVL tree insertion
<ul>
<li>Procedures
<ul>
<li>Insert the new key as a new leaf just as in ordinary BST</li>
<li>Trace the path from the new leaf towards the root</li>
<li>For each node encountered calculate the balance factor</li>
<li>If the balance factor is 2 or -2, balance the tree</li>
</ul></li>
<li>For insertion, once you perform a rotation at a node v, no need to
perform any rotation at ancestors of v</li>
<li>Determine how to rotate after insertion
<ul>
<li>If <code>v.bf &lt; -1</code>
<ul>
<li>If <code>v.right.bf &gt; 0</code>: right rotate at v.right, then
left rotate at v</li>
<li>IF <code>v.right.bf &lt; 0</code>: left rotate at v</li>
</ul></li>
<li>If <code>v.bf &gt; 1</code>
<ul>
<li>If <code>v.left.bf &lt; 0</code>: left rotate at v.left, then right
rotate at v</li>
<li>If <code>v.left.bf &gt; 0</code>: right rotate at v</li>
</ul></li>
</ul></li>
</ul></li>
<li>AVL tree deletion
<ul>
<li>Perform BST deletion first</li>
<li>If node v is deleted, trace the path from v.parent to root, check
and rotate each imbalanced node</li>
</ul></li>
<li>AVL tree runtime analysis
<ul>
<li>Search, insertion, deletion are all guaranteed to be <span class="math inline">\(O(logN)\)</span></li>
</ul></li>
<li>Splay trees
<ul>
<li>Splay tree is invented by Daniel Sleator and Robert Tarjan in
1983</li>
<li>Splay trees are self-balancing binary search tree with additional
property that recently accessed elements are quick to access again (the
idea of locality)</li>
<li>Splay trees do not store balance factor, they are usually nicely
balanced, but height can potentially be N - 1</li>
<li>Basic operations: search, insertion and deletion in amortized <span class="math inline">\(O(logN)\)</span> time. <span class="math inline">\(O(N)\)</span> operations can occur, but splaying
makes them infrequent</li>
<li>Splay tree rotations
<ul>
<li>If the target node X is the root of a splay tree, then no rotation
is involved</li>
<li>If the target X is the child of root, then single rotation is
needed. A single rotation, either left or right, is called zig</li>
<li>If the target node X has a parent P, and a grandparent G, then
double rotation is involved. The double rotation, either RL rotation, or
LR rotation, is called zig-zag</li>
</ul></li>
<li>Splay tree search
<ul>
<li>Like BST search</li>
<li>Let X be the node where the search ends (succeed or not)</li>
<li>Take node X and splay up to the root of the tree using a sequence of
rotations</li>
</ul></li>
<li>Insert X
<ul>
<li>Like BST insert</li>
<li>Splay X to the root</li>
</ul></li>
<li>Delete X
<ul>
<li>First splay X to the root, and remove</li>
<li>If two subtrees remain, find the largest one from the left subtree
and let it the be the new root</li>
<li>If one subtree remain, let the root of the subtree be the root of
the tree</li>
<li>If no nodes remain, let the root be null</li>
</ul></li>
<li>Find max and min
<ul>
<li>Like BST</li>
<li>Once find the max/min, splay it to the root</li>
</ul></li>
<li>Disadvantage of splay tree
<ul>
<li>Amortized <span class="math inline">\(O(logN)\)</span>, it can be
linear</li>
<li>For each operation, splay is needed, so there is computational
overhead in maintaining a splay tree</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-21-20220316">Lecture 21 2022/03/16</h2>
<ol type="1">
<li>Searching
<ul>
<li>Organization and retrieval of information is at the heart of most
computer applications, and searching is the most frequently performed
task</li>
<li>If an array is not sorted, then search is <span class="math inline">\(O(N)\)</span>, if an array is sorted, then binary
search is <span class="math inline">\(O(logN)\)</span></li>
</ul></li>
<li>Hash table ideas
<ul>
<li>Hashing is a technique used for performing insertion, deletion, and
search in constant average time</li>
<li>The data structure used is the hash table</li>
<li>Hash table operations: <code>insert(T, x)</code>,
<code>delete(T, x)</code>, <code>search(T, x)</code></li>
<li>A table is simply another term for an array, it has several fields,
to find an entry in the table, you only need to know the content of one
of the fields(key, the key uniquely identifies an entry)</li>
</ul></li>
<li>Direct addressing table
<ul>
<li>Direct address tables are ordinary arrays</li>
<li>Elements whose key is k obtained by indexing into the kth position
of the array (if the maximum element in the table is n, then the length
of a direct address table is also n)</li>
<li>Insert, delete, search can be implemented to take <span class="math inline">\(O(1)\)</span> time</li>
<li>Disadvantages
<ul>
<li>The size of direct-address table is large</li>
<li>There could be a lot of empty space in direct address table</li>
</ul></li>
</ul></li>
<li>Hash table
<ul>
<li>The ideal hash table is an array of some fixed size, containing
items, and the operations are <span class="math inline">\(O(1)\)</span>
on average</li>
<li>Hash function: a hash function transforms a key k into a number that
is used as an index in an array to locate the desired location
<ul>
<li>An element with k hashes to slot h(k), where h(k) is the hash value
of key k</li>
<li>Hash function should be simple to compute, any two distinct keys
should get different cells</li>
</ul></li>
<li>Division method: <code>h(k) = k % m</code>, where m is the size of
the table</li>
<li>Issues with hashing
<ul>
<li>Decide what to do when two keys hash to the same value</li>
<li>Choose a good hash function</li>
<li>Choose the size of the table</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-22-20220317">Lecture 22 2022/03/17</h2>
<ol type="1">
<li>Collision
<ul>
<li>Collision: different keys mapped onto the same hash value</li>
<li>Design a good hash function will minimize the number of collisions
that occcur, but they will still happen, there are two basic collision
resolution techniques</li>
<li>Chaining
<ul>
<li>Store all elements that hash to the same slot in a linked list</li>
<li>Store a pointer to the head of the linked list in the hash table
slot</li>
<li>Invented by H.P. Luhn in 1953</li>
<li>Operations
<ul>
<li><code>insert(T, x)</code>: insert x at the head of list
<code>T[h(x.key)]</code></li>
<li><code>search(T, x)</code>: search for an element with key k in list
<code>T[h(k)]</code></li>
<li><code>delete(T, x)</code>: delete x from the list
<code>T[h(x.key)]</code></li>
</ul></li>
<li>Chaining is used when we cannot predict the number of records in
advance, thus the choice of the size of the table depends on available
memory</li>
<li>Recommendations of table size m:
<ul>
<li><code>m ~= 0.1 * n</code></li>
<li><code>m ~= n</code></li>
</ul></li>
</ul></li>
<li>Open addressing
<ul>
<li>All elements stored in hash table itself</li>
<li>When collision occur, use a systematic procedure to store elements
in free slots of the table</li>
<li>Invented by Ershov and Peterson in 1957 independently</li>
<li>If collision occurs, use this formula to do probing:
<code>h(k) = (hash(k) + f(i)) % m</code>, where <code>h(k)</code> is the
index in the table indicating where to insert k, <code>hash(k)</code> is
the hash function of k, <code>f(i)</code> is the collision resolution
function with <code>i = 0, 1, ..., m-1</code>, which means we start from
<code>hash(k)</code> and try each i to find if <code>h(k)</code> is
available, <code>m</code> is the size of the hash table</li>
<li>Different collision resolution functions
<ul>
<li>Linear probing: <code>f(i) = i</code></li>
<li>Quadratic probing: <code>f(i) = i^2</code></li>
<li>Double hashing: <code>f(i) = i * hash2(k)</code></li>
</ul></li>
<li>Linear probing
<ul>
<li>Insert <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">insert(T, k)</span><br><span class="line">  i &#x3D; 0</span><br><span class="line">  repeat</span><br><span class="line">    j &#x3D; h(k, i)</span><br><span class="line">    if T[j] &#x3D; NIL then</span><br><span class="line">        T[j] &#x3D; k</span><br><span class="line">        return j</span><br><span class="line">    else </span><br><span class="line">      i &#x3D; i + 1</span><br><span class="line">  until i &#x3D; m</span><br><span class="line">  error &#39;hash table overflow&#39;</span><br></pre></td></tr></table></figure></li>
<li>Search <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">search(T, k)</span><br><span class="line">  i &#x3D; 0</span><br><span class="line">  repeat</span><br><span class="line">    j &#x3D; h(k, i)</span><br><span class="line">    if T[j] &#x3D; k then</span><br><span class="line">      return j</span><br><span class="line">    else </span><br><span class="line">      i &#x3D; i + 1</span><br><span class="line">  until T[j] &#x3D; NIL or i &#x3D; m</span><br><span class="line">  return NIL</span><br></pre></td></tr></table></figure></li>
<li>Delete is more difficult
<ul>
<li>If we delete a key from slot h(k), we cannot mark the slot NIL,
because there maybe other probing slots based on this slot</li>
<li>We need to mark the slot with a special value, modify search so that
it keeps on looking when it sees the special value, insert would treat
the slot with a special value as empty slot, so a new value can be
added</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-23-20220321">Lecture 23 2022/03/21</h2>
<ol type="1">
<li>Clustering
<ul>
<li>Primary Clustering: many consecutive elements form groups and it
takes time to find a free slot or to search for an element</li>
<li>Secondary Clustering: two records only have the same collision chain
if their initial position is the same</li>
<li>Linear probing has primary clustering problem</li>
<li>Quadratic probing has secondary probing problem</li>
</ul></li>
<li>Quadratic probing
<ul>
<li>Hash function: <code>h(k) = (hash(k) + f(i)^2) % m</code></li>
<li>Problems: if the initial position is the same, then the collision
chain will be the same</li>
</ul></li>
<li>Double hashing:
<ul>
<li>Hash function:
<code>h(k) = (hash1(k) + i * hash2(k)) % m</code></li>
<li>A popular choice of hash2(k): <code>hash2(k) = R - (k % R)</code>,
where R is a primer number that is smaller than the size of the
table</li>
</ul></li>
<li>Cuckoo hashing
<ul>
<li>Invented by Pagh and Rodler in 2001</li>
<li>Idea: when we insert k1, if k2 occupies the slot, we kick it out and
find k2 a new slot</li>
<li>Collision strategy
<ul>
<li>Each hash table has a hash function h1 and h2</li>
<li>We prefer h1, but if we must move, we use h2</li>
</ul></li>
<li>Cuckoo hashing guarantees <span class="math inline">\(O(1)\)</span>
search and <span class="math inline">\(O(1)\)</span> insert</li>
</ul></li>
<li>Load factor
<ul>
<li>Def: given a hash table T with m slots that stores n elements, load
factor <span class="math inline">\(\alpha = n / m\)</span></li>
<li>Hash with chaining: load factor can be greater than 1</li>
<li>Hash with open addressing: load factor is <span class="math inline">\(0 \leq \alpha \leq 1\)</span></li>
<li>If the load factor is high, then it's likely that there are
collisions, if the load factor is low, then there are many empty
slots</li>
<li>If the load factor exceeds certain criteria value, then we need to
do rehashing, which is an <span class="math inline">\(O(N)\)</span>
operation</li>
</ul></li>
</ol>
<h2 id="lecture-24-20220323">Lecture 24 2022/03/23</h2>
<ol type="1">
<li>Hash function
<ul>
<li>A good hash function should
<ul>
<li>Be easy and quick to compute</li>
<li>Achieve an even distribution of the key values that actually occur
across the index range supported by the table</li>
<li>Minimal number of collision</li>
</ul></li>
<li>Some hash functions
<ul>
<li>Middle of square: middle digits of <span class="math inline">\(k^2\)</span></li>
<li>Division: k % m</li>
<li>Multiplicative: the first few digits of the fractional part of k *
A, where <span class="math inline">\(A = (\sqrt(5) - 1) /
2\)</span></li>
<li>Truncation or folding</li>
<li>String hash function: <span class="math inline">\(h(s) =
s(k-1)p^{k-1} + s(1)p + s(0)\)</span></li>
</ul></li>
</ul></li>
<li>Sorting
<ul>
<li>Introduction
<ul>
<li><span class="math inline">\(O(N^2)\)</span> sorting: bubble sort,
insertion sort, selection sort, shell sort</li>
<li><span class="math inline">\(O(NlogN)\)</span> sorting: merge sort,
heap sort, quick sort</li>
<li><span class="math inline">\(O(N)\)</span> sorting: counting sort,
radix sort, bucket sort</li>
</ul></li>
</ul></li>
<li>Bubble sort
<ul>
<li>Oldest and simplest sorting algorithm</li>
<li>Idea: large values bubble to the end of the list while smaller
values sink towards the beginning of the list</li>
<li>Algorithm
<ul>
<li>Compare every pair of adjacent items, swap if necessary</li>
<li>Repeat this process until no swap is made in one pass</li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[j + <span class="number">1</span>];</span><br><span class="line">        a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> disSwap = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (disSwap) &#123;</span><br><span class="line">    disSwap = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a[i + <span class="number">1</span>];</span><br><span class="line">        a[i + <span class="number">1</span>] = a[i];</span><br><span class="line">        a[i] = tmp;</span><br><span class="line">        disSwap = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Run time:
<ul>
<li>Worst case: <span class="math inline">\(O(N^2)\)</span></li>
<li>Best case: when sorted, <span class="math inline">\(O(N)\)</span></li>
</ul></li>
<li>In-place: yes</li>
<li>Stable: yes, only swap when <code>A[j] &gt; A[j + 1]</code></li>
</ul></li>
</ol>
<h2 id="lecture-25-20220324">Lecture 25 2022/03/24</h2>
<ol type="1">
<li>Insertion sort
<ul>
<li>Idea: Start with an empty left part, remove one item from the right,
insert it into the correct position in the left part</li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key) &#123;</span><br><span class="line">      a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Run time
<ul>
<li>Worst case: <span class="math inline">\(O(N^2)\)</span></li>
<li>Best case: <span class="math inline">\(O(N)\)</span></li>
</ul></li>
<li>In-place: yes</li>
<li>Stable: yes, only swap when <code>A[j] &gt; key</code></li>
</ul></li>
<li>Selection sort
<ul>
<li>Idea: select the smallest unsorted item in the list, swap it with
the value in the first position, repeat the steps for the remainder of
the list</li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j] &lt; a[min]) &#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[min];</span><br><span class="line">    a[min] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Runtime
<ul>
<li>Worst case: <span class="math inline">\(O(N^2)\)</span></li>
<li>Best case: <span class="math inline">\(O(N^2)\)</span></li>
</ul></li>
<li>In-place: yes</li>
<li>Stable: yes, change min index only when
<code>a[j] &lt; a[min]</code></li>
</ul></li>
<li>Shell sort
<ul>
<li>More efficient than bubble sort, insertion sort and selection
sort</li>
<li>A variation of the insertion sort</li>
<li>It compares elements that are distant rather than adjacent elements
in an array or list</li>
<li>We can choose distant elements using gap size, gap size is one half
of the length of the array and halved until each item is compared with
its neighbor</li>
<li>Idea
<ul>
<li>Divide array to be sorted into some number of sub-arrays</li>
<li>Sort each of the sub-arrays using insertion sort</li>
<li>Repeat until the length of sub-arrays being sorted is one</li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> key = arr[gap]; <span class="comment">// Should be arr[i]</span></span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123; <span class="comment">// Comparison should be arr[j - gap]</span></span><br><span class="line">        arr[j] = arr[j - gap]; <span class="comment">// Shift</span></span><br><span class="line">        j = j - gap;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = key; <span class="comment">// Insert</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <em>Correction for Shell Sort
(based on typical implementations):</em> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> key = arr[i]; <span class="comment">// Corrected</span></span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt;= gap &amp;&amp; arr[j - gap] &gt; key) &#123; <span class="comment">// Corrected</span></span><br><span class="line">        arr[j] = arr[j - gap]; <span class="comment">// Corrected</span></span><br><span class="line">        j -= gap; <span class="comment">// Corrected</span></span><br><span class="line">      &#125;</span><br><span class="line">      arr[j] = key; <span class="comment">// Corrected</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>It has been proven that the gap size should not be a power of 2, use
prime numbers or odd numbers instead</li>
<li>Runtime
<ul>
<li>Worst case: <span class="math inline">\(O(N^2)\)</span></li>
<li>Best case: <span class="math inline">\(O(N)\)</span> (actually more
like <span class="math inline">\(O(NlogN)\)</span> for good gap
sequences, but <span class="math inline">\(O(N)\)</span> if nearly
sorted)</li>
</ul></li>
<li>In-place: yes</li>
<li>Stable: no, shell sort uses gap intervals, so it may change the
relative order of equal elements</li>
</ul></li>
</ol>
<h2 id="lecture-26-20220328">Lecture 26 2022/03/28</h2>
<ol type="1">
<li>Merge sort
<ul>
<li>It's invented by Neumann in 1945</li>
<li>It is a divide and conquer algorithm</li>
<li>Idea
<ul>
<li>Divide the array into two equal-length sub-arrays</li>
<li>Conquer by recursively sorting the two sub-arrays</li>
<li>Combine by merging the two sorted sub-arrays to produce a single
sorted array</li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n1 = mid - lo + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n2 = hi - mid;</span><br><span class="line">  <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[n1]; <span class="comment">// L is arr[lo, ..., mid]</span></span><br><span class="line">  <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[n2]; <span class="comment">// R is arr[mid + 1, ..., hi]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">    L[i] = arr[lo + i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">    R[j] = arr[mid + <span class="number">1</span> + j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = lo;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;</span><br><span class="line">      arr[k] = L[i];</span><br><span class="line">      i += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[k] = R[j];</span><br><span class="line">      j += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">    arr[k] = L[i];</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    k += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">    arr[k] = R[j];</span><br><span class="line">    j += <span class="number">1</span>;</span><br><span class="line">    k += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortHelper</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">  mergeSortHelper(arr, lo, mid);</span><br><span class="line">  mergeSortHelper(arr, mid + <span class="number">1</span> , hi);</span><br><span class="line">  merge(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  mergeSortHelper(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Runtime
<ul>
<li>Worst case: <span class="math inline">\(O(NlogN)\)</span></li>
<li>Best case: <span class="math inline">\(O(NlogN)\)</span></li>
</ul></li>
<li>In-place: no</li>
<li>Stable: yes</li>
</ul></li>
<li>Recurrence relation
<ul>
<li>Methods
<ul>
<li>Iterative</li>
<li>Recursion tree method</li>
<li>Master theorem method</li>
</ul></li>
<li>Recursion tree method
<ul>
<li>Example 1: <span class="math inline">\(T(n) = 2 * T(n/2) +
O(n)\)</span>: <span class="math inline">\(T(n) = n + ... + n = n *
logn\)</span></li>
<li>Example 2: <span class="math inline">\(T(n) = T(n/4) + T(n/2) +
n^2\)</span>: <span class="math inline">\(T(n) = n^2 * \sum\limits_{i =
0}^{k}(\frac{5}{16})^i &lt; n^2 * \sum\limits_{i = 0}
^{\infty}(\frac{5}{16})^i = \frac{16 n^2}{11}\)</span></li>
<li>Example 3: <span class="math inline">\(T(n) = 3 T(n/4) +
cn^2\)</span>: <span class="math inline">\(T(n) &lt;
\frac{16n^2}{13}\)</span></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-27-20220330">Lecture 27 2022/03/30</h2>
<ol type="1">
<li>Quick sort
<ul>
<li>Idea: sort array A[p, ..., q]
<ul>
<li>Divide: partition the array into two sub-arrays around an element
called pivot x, (A[p, ..., x - 1], A[x + 1, ..., q]). Elements in the
lower sub-array are less than or equal to x, elements in the upper
sub-array are greater than or equal to x</li>
<li>Conquer: recursively sort the two sub-arrays</li>
<li>Combine: trivial</li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; <span class="comment">// Return type should be int</span></span><br><span class="line">  <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">  <span class="comment">// i is the index of rightmost item that is &lt;= pivot</span></span><br><span class="line">  <span class="keyword">int</span> i = lo;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = lo + <span class="number">1</span>; j &lt;= hi; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">      i += <span class="number">1</span>; </span><br><span class="line">      <span class="comment">// arr[i] the first item &gt; pivot, a[j] &lt;= pivot, so we swap the two</span></span><br><span class="line">      <span class="comment">// after swap, i again is the index of rightmost item that is &lt;= pivot</span></span><br><span class="line">      <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Swap pivot (arr[lo]) with arr[i] to place pivot in correct position</span></span><br><span class="line">  arr[lo] = arr[i]; </span><br><span class="line">  arr[i] = pivot;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSortInner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> x = partition(arr, lo, hi);</span><br><span class="line">  quickSortInner(arr, lo, x - <span class="number">1</span>);</span><br><span class="line">  quickSortInner(arr, x + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = arr.length;</span><br><span class="line">  quickSortInner(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Runtime
<ul>
<li>Worst case: <span class="math inline">\(O(N^2)\)</span></li>
<li>Best case: <span class="math inline">\(O(NlogN)\)</span></li>
</ul></li>
<li>In-place: yes</li>
<li>Stable: no, it swaps elements according to the pivot's position</li>
</ul></li>
</ol>
<h2 id="lecture-28-20220331">Lecture 28 2022/03/31</h2>
<ol type="1">
<li>Randomized quick sort
<ul>
<li>Motivation: we don't want quick sort to be <span class="math inline">\(O(N^2)\)</span></li>
<li>Idea: partition around a random element
<ul>
<li>Running time is independent of the input order</li>
<li>No assumptions need to be made about the input distribution</li>
<li>The worst case is determined only by the output of a random-number
generator</li>
</ul></li>
<li>Pick a random element as the pivot</li>
</ul></li>
<li>Sorting in linear time
<ul>
<li>Comparison-based sorting algorithms:
<ul>
<li>Merge sort and heap sort achieve <span class="math inline">\(O(NlogN)\)</span> time in worst case</li>
<li>Quick sort achieves <span class="math inline">\(O(NlogN)\)</span>
time on average</li>
</ul></li>
<li>Non comparison-based linear time sorting algorithms:
<ul>
<li>Example: counting sort, radix sort, and bucket sort</li>
</ul></li>
<li>Counting sort
<ul>
<li>Algorithm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">countingSort(A, B, k)</span><br><span class="line">  # Input: A[1...n], where A[i] in &#123;1, 2, ..., k&#125;</span><br><span class="line">  # Output: B[1...n], B is sorted</span><br><span class="line">  </span><br><span class="line">  Initialize C[0...k]</span><br><span class="line">  for i &lt;- 0 to k do</span><br><span class="line">    C[i] &lt;- 0</span><br><span class="line">  for j &lt;- 1 to size of A do</span><br><span class="line">    C[A[j]] &lt;- C[A[j]] + 1  # Calculate the frequency of items in array A</span><br><span class="line">  for i &lt;- 1 to k do</span><br><span class="line">    C[i] &lt;- C[i] + C[i - 1] # Cumulative frequency, also the last index of an item in the sorted array</span><br><span class="line">  for j &lt;- size of A downto 1 do</span><br><span class="line">    B[C[A[j]]] &lt;- A[j]</span><br><span class="line">    C[A[j]] &lt;- C[A[j]] - 1</span><br></pre></td></tr></table></figure></li>
<li>Stable: yes</li>
<li>Complexity: <span class="math inline">\(O(N + k)\)</span></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-29-20220404">Lecture 29 2022/04/04</h2>
<ol type="1">
<li>Heap
<ul>
<li>Introduction
<ul>
<li>A heap is a tree-like data structure that can be implemented as an
array</li>
<li>Each node of the tree corresponds to an element of the array and
every node must satisfy the heap properties</li>
<li>There are different variants of heap: 2-3 heap, beap, Fibonacci
heap, d-ary heap, binary heap</li>
</ul></li>
<li>Binary heap
<ul>
<li>A binary heap is a complete binary tree that satisfies the heap
property
<ul>
<li>Let v and u be nodes of a heap, such that u is a child of v</li>
<li>If <code>v.data &gt;= u.data</code>, we have a max heap</li>
<li>If <code>v.data &lt;= u.data</code>, we have a min heap</li>
<li>Min heap: a complete binary tree where the key of each node is less
than the keys of its children</li>
<li>Max heap: a complete binary tree where the key of each node is
greater than the keys of tis children</li>
</ul></li>
<li>Array index of a binary heap
<ul>
<li>When the array of a binary heap is 1-indexed, if node v is at index
n, its left child is at index 2 * n, its right child is at index 2 * n +
1, its parent is at index [n / 2]</li>
<li>When the array of a binary heap is 0-indexed, if node v is at index
n, its left child is at index 2 * n + 1, its right child is at index 2 *
n + 2, its parent is at index [(n - 1) / 2]</li>
</ul></li>
<li>Basic heap operations
<ul>
<li>Build-max-heap/build-min-heap: create a max-heap/min-heap from an
unordered array</li>
<li>Insert a node: new nodes are always inserted at the bottom level
from left to right</li>
<li>Delete a node: nodes are removed from the bottom level from right to
left</li>
<li>Heapsort: sort an array in place</li>
<li>Heapify: the key to maintain the heap property
<ul>
<li>Heapify up/percolate up</li>
<li>Heapify down/percolate down</li>
</ul></li>
</ul></li>
<li>Implementation
<ul>
<li>Heapify down for max heap, time complexity: <span class="math inline">\(O(logN)\)</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming A is 1-indexed for simplicity, or adjust indices for 0-indexed</span></span><br><span class="line"><span class="comment">// n is the effective size of the heap within array A</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapifyDown</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">2</span> * k;</span><br><span class="line">  <span class="keyword">int</span> right = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> largest = k;</span><br><span class="line">  <span class="keyword">if</span> (left &lt;= n &amp;&amp; A[left] &gt; A[largest]) &#123; <span class="comment">// Use &lt;= n for 1-indexed</span></span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt;= n &amp;&amp; A[right] &gt; A[largest]) &#123; <span class="comment">// Use &lt;= n</span></span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (largest != k) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = A[k];</span><br><span class="line">    A[k] = A[largest];</span><br><span class="line">    A[largest] = tmp;</span><br><span class="line">    heapifyDown(A, largest, n); <span class="comment">// Pass n</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Heapify up for max heap, time complexity: <span class="math inline">\(O(logN)\)</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming A is 1-indexed and k is the index of the element to heapify up</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapifyUp</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; A[k] &gt; A[k / <span class="number">2</span>]) &#123; <span class="comment">// A[i] in HTML, assuming it means A[k]</span></span><br><span class="line">    <span class="keyword">int</span> tmp = A[k];</span><br><span class="line">    A[k] = A[k / <span class="number">2</span>];</span><br><span class="line">    A[k / <span class="number">2</span>] = tmp;</span><br><span class="line">    k = k / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-30-20220406">Lecture 30 2022/04/06</h2>
<ol type="1">
<li>Heap
<ul>
<li>Height: since a heap is a complete binary tree, the height of a heap
of N elements is <span class="math inline">\(logN\)</span></li>
<li>Basic operations on heaps run in proportional to the height, <span class="math inline">\(O(logN)\)</span></li>
<li>Build a max heap, time complexity: <span class="math inline">\(O(NlogN)\)</span> (can be <span class="math inline">\(O(N)\)</span> with optimized build)
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming A is 1-indexed, and len is its actual length (e.g., A.length - 1 if slot 0 is unused)</span></span><br><span class="line"><span class="comment">// n is the number of elements in the heap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// Start from the parent of the last element</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">// Corrected loop condition, no i /= 2</span></span><br><span class="line">    heapifyDown(A, i, n); <span class="comment">// Pass n</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>In order to build a min heap, the logic is the same, the only
modification is in the hepifyDown method that we need to swap the
element with its smallest child when necessary</li>
<li>Heapsort
<ul>
<li>Goal: sort an array using heap implementation</li>
<li>Idea:
<ul>
<li>Build a max heap from an array</li>
<li>Swap the root with the last element in the array</li>
<li>Decrease the size of the heap by 1</li>
<li>Call heapify down on the new root</li>
<li>Repeat this process until only one node remains in the heap</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming A is 1-indexed, and A.length gives size+1</span></span><br><span class="line"><span class="comment">// For a 0-indexed array, adjustments are needed.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = A.length - <span class="number">1</span>; <span class="comment">// Number of elements if 1-indexed</span></span><br><span class="line">  buildMaxHeap(A, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = A[<span class="number">1</span>];</span><br><span class="line">    A[<span class="number">1</span>] = A[i];</span><br><span class="line">    A[i] = tmp;</span><br><span class="line">    <span class="comment">// heap.size -= 1; // Implicitly done by reducing n in heapifyDown call</span></span><br><span class="line">    heapifyDown(A, <span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">// Heap size reduces</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Time complexity: <span class="math inline">\(O(NlogN)\)</span></li>
<li>In place: yes</li>
<li>Stable: no</li>
</ul></li>
</ul></li>
<li>Priority Queue
<ul>
<li>A priority queue is a data structure for maintaining a set of
elements with priorities, the key withe the highest/lowest priority is
extracted first</li>
<li>Max priority queue operations
<ul>
<li>Insert(A, x): insert the element x in A, x has a priority with
it</li>
<li>Extract-Max(A): removes and returns the element of A with the
largest key</li>
<li>Maximum(A): returns the element of A with the largest key</li>
<li>Increase-key(A, x, k): increase the value of element's priority to
the new value k, which is assumed to be at least as large as x's current
priority</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming 1-indexed array A and heapSize attribute for the heap object</span></span><br><span class="line"><span class="comment">// O(1) operation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Heap heap)</span> </span>&#123; <span class="comment">// Pass heap object or manage size differently</span></span><br><span class="line">  <span class="keyword">return</span> heap.A[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logN) operation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">extractMax</span><span class="params">(Heap heap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (heap.heapSize &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Heap underflow&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span> max = heap.A[<span class="number">1</span>];</span><br><span class="line">  heap.A[<span class="number">1</span>] = heap.A[heap.heapSize];</span><br><span class="line">  heap.heapSize -= <span class="number">1</span>;</span><br><span class="line">  heapifyDown(heap.A, <span class="number">1</span>, heap.heapSize);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logN) operation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseKey</span><span class="params">(Heap heap, <span class="keyword">int</span> i, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key &lt; heap.A[i]) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;New key is smaller than current key&quot;</span>);</span><br><span class="line">  heap.A[i] = key;</span><br><span class="line">  heapifyUp(heap.A, i); <span class="comment">// heapifyUp needs to know about A and its structure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(logN) operation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Heap heap, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">  heap.heapSize += <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Assuming array A can accommodate heapSize</span></span><br><span class="line">  heap.A[heap.heapSize] = Integer.MIN_VALUE; <span class="comment">// sentinel or placeholder</span></span><br><span class="line">  increaseKey(heap, heap.heapSize, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h2 id="lecture-31-20220407">Lecture 31 2022/04/07</h2>
<ol type="1">
<li>Graph
<ul>
<li>A graph models a set of connections</li>
<li>A graph G = (V, E) consists of
<ul>
<li>A finite set V of vertices, |V| is called the order of a graph</li>
<li>A finite set E of edges, |E| is called the size of a graph, each
edge is a pair (u, v) where u, v <span class="math inline">\(\in\)</span> V</li>
</ul></li>
<li>Applications of Graphs
<ul>
<li>Road maps</li>
<li>Chemical structures</li>
<li>Games/ puzzles</li>
<li>Computer networks</li>
<li>Web links</li>
</ul></li>
<li>Edge types
<ul>
<li>Direction
<ul>
<li>Directed edge: ordered pair of vertices (u, v), u is called the
origin, v is called the destination</li>
<li>Undirected edge: unordered pair of vertices (u, v)</li>
</ul></li>
<li>Weight
<ul>
<li>Weighted edge</li>
<li>Unweighted edge</li>
</ul></li>
<li>A graph may be directed or undirected, weighted or unweighted</li>
</ul></li>
<li>Terminology
<ul>
<li>Adjacent vertices: two vertices connected by an edge</li>
<li>Degree of a vertex: the number of edges starting or ending at that
vertex
<ul>
<li>In-degree: the number of edges ending at a vertex</li>
<li>Out-degree: the number of edges starting at a vertex</li>
</ul></li>
<li>Path: a sequence of edges</li>
<li>Length of a path: the number of edges on a path</li>
<li>Simple path: a path where all its vertices and edges are
distinct</li>
<li>Cycle: a path beginning and ending at the same vertex</li>
<li>Simple cycle: a simple cycle is a cycle which does not pass through
any vertex more than once</li>
<li>Loop: an edge whose endpoints are the same vertex</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-32-20220411">Lecture 32 2022/04/11</h2>
<ol type="1">
<li>Implementing graphs
<ul>
<li>Data structure for vertices
<ul>
<li>Hash table (generally preferred)</li>
<li>Array</li>
<li>List</li>
<li>Binary search tree</li>
</ul></li>
<li>Data structures for edges
<ul>
<li>Adjacency list</li>
<li>Adjacency matrix</li>
</ul></li>
<li>Adjacency list
<ul>
<li>Consists of an array of length |V|, each position in the list is for
a vertex in V</li>
<li>For the position associated with vertex u in the array, the
adjacency list consists of all vertices v such that there is an edge (u,
v) <span class="math inline">\(\in\)</span> E</li>
</ul></li>
<li>Adjacency matrix
<ul>
<li>It consists of an |V| * |V| binary matrix M</li>
<li>If the graph is directed, <span class="math inline">\(M[i][j] = 1
\iff (i, j) \in E\)</span></li>
<li>If the graph is undirected, <span class="math inline">\(M[i][j] =
M[j][i] = 1 \iff (i, j) \in E\)</span></li>
</ul></li>
<li>The time complexity of graph algorithms are often expressed in |E|
and |V|</li>
</ul></li>
<li>Graph traversal
<ul>
<li>Two kinds of graph traversal algorithm
<ul>
<li>Breadth-first search (BFS)</li>
<li>Depth-first search (DFS)</li>
</ul></li>
<li>BFS
<ul>
<li>BFS is the archetype for many graph algorithms: Dijkstra's shortest
path algorithm, Prim's minimum spanning tree algorithm</li>
<li>Idea: given a graph G and a source vertex s, BFS systemically
explores the edge of G to discover every vertex that is a reachable from
s</li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming G.V() gives number of vertices, G.adj(u) gives adjacency list for u</span></span><br><span class="line"><span class="comment">// Vertices are 0-indexed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// you can also use boolean[] visited = new boolean[G.V()]</span></span><br><span class="line">  <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">    dist[i] = Integer.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// Using Java&#x27;s LinkedList as a Queue</span></span><br><span class="line">  queue.add(s); <span class="comment">// enqueue</span></span><br><span class="line">  <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = queue.remove(); <span class="comment">// dequeue</span></span><br><span class="line">    System.out.println(u); <span class="comment">// Or some other visit action</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: G.adj(u)) &#123;</span><br><span class="line">      <span class="comment">// if vertex v has not been visited</span></span><br><span class="line">      <span class="keyword">if</span> (dist[v] == Integer.MAX_VALUE) &#123;</span><br><span class="line">        dist[v] = dist[u] + <span class="number">1</span>;</span><br><span class="line">        queue.add(v); <span class="comment">// enqueue</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Time complexity: <span class="math inline">\(O(V + E)\)</span></li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-33-20220413">Lecture 33 2022/04/13</h2>
<ol type="1">
<li>Shortest path problem
<ul>
<li>Use a weighted graph</li>
<li>The weight of a path is the sum of the weights of its edges</li>
<li>Let <span class="math inline">\(\{w(p): u \rightarrow v\}\)</span>
be the set of the weights of all paths from u to v, if the set has a
minimum, we call the minimum the shortest path weight from u to v,
denote <span class="math inline">\(\delta(u, v)\)</span>. If the set
does not has a minimum, denote <span class="math inline">\(\delta(u, v)
= \infty\)</span> (If u and v are not connected, or if there is a cycle
with negative weight in the path from u to v)</li>
<li>Single source shortest path problem with Dijkstra's algorithm
<ul>
<li>Description: find a shortest path from a given source vertex s to
each of the vertices in the graph</li>
<li>Assumptions
<ul>
<li>Directed graph</li>
<li>All edges must have nonnegative weights</li>
<li>Connected graph</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assuming G.V(), G.adj(u), G.weight(u,v)</span></span><br><span class="line"><span class="comment">// Vertices 0-indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(Graph G, <span class="keyword">int</span> src) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">  <span class="comment">// prev[i] is the previous vertex of vertex i in the shortest path from src to i</span></span><br><span class="line">  <span class="comment">// path from src to i is prev[i] -&gt; prev[prev[i]] -&gt; ... -&gt; src</span></span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">    dist[i] = Integer.MAX_VALUE;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(G.V(), <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> dist[a] - dist[b];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++) &#123;</span><br><span class="line">    pq.add(i); <span class="comment">// Add all vertices to PQ; their priority is based on dist[]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!pq.isEmpty()) &#123; </span><br><span class="line">    <span class="keyword">int</span> u = pq.poll(); <span class="comment">// remove/dequeue</span></span><br><span class="line">    <span class="comment">// If u is unreachable, or already processed via a shorter path if not using indexed PQ</span></span><br><span class="line">    <span class="keyword">if</span> (dist[u] == Integer.MAX_VALUE) <span class="keyword">continue</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v: G.adj(u)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dist[v] &gt; dist[u] + G.weight(u, v)) &#123;</span><br><span class="line">        dist[v] = dist[u] + G.weight(u, v);</span><br><span class="line">        prev[v] = u;</span><br><span class="line">        pq.remove(v); <span class="comment">// Optional: efficiency</span></span><br><span class="line">        pq.add(v);    <span class="comment">// Re-add with new priority</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Time complexity: <span class="math inline">\(O((V + E)logV)\)</span>
with a binary heap based Priority Queue. <span class="math inline">\(O(E
+ VlogV)\)</span> with Fibonacci heap.</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-34-20220414">Lecture 34 2022/04/14</h2>
<ol type="1">
<li>Depth-first search
<ul>
<li>Problems solved by DFS
<ul>
<li>Testing whether a graph is connected</li>
<li>Computing a path between two vertices or equivalently reporting that
no such path exists</li>
<li>Compute a cycle or equivalently reporting the no such cycle
exists</li>
</ul></li>
<li>Algorithm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Global or class members: color[], time, i[], f[]</span><br><span class="line">&#x2F;&#x2F; color: WHITE, GRAY, BLACK</span><br><span class="line">&#x2F;&#x2F; i[]: discovery time, f[]: finish time</span><br><span class="line">DFS(V, E) &#x2F;&#x2F; Graph G</span><br><span class="line">  for each u in V do</span><br><span class="line">    u.color &#x3D; WHITE</span><br><span class="line">    &#x2F;&#x2F; u.parent &#x3D; NIL (if tracking DFS tree)</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  for each u in V do</span><br><span class="line">    if u.color &#x3D;&#x3D; WHITE then</span><br><span class="line">      DFS-VISIT(u) &#x2F;&#x2F; Pass G or make adj list accessible</span><br><span class="line"></span><br><span class="line">DFS-VISIT(u) &#x2F;&#x2F; Pass G</span><br><span class="line">  u.color &#x3D; GRAY</span><br><span class="line">  time &#x3D; time + 1</span><br><span class="line">  u.i &#x3D; time &#x2F;&#x2F; discovery time for u</span><br><span class="line">  for each v in Adj(u) do &#x2F;&#x2F; G.adj(u)</span><br><span class="line">    if v.color &#x3D;&#x3D; WHITE then</span><br><span class="line">      &#x2F;&#x2F; v.parent &#x3D; u (if tracking DFS tree)</span><br><span class="line">      DFS-VISIT(v)</span><br><span class="line">  u.color &#x3D; BLACK</span><br><span class="line">  time &#x3D; time + 1</span><br><span class="line">  u.f &#x3D; time &#x2F;&#x2F; finish time for u</span><br></pre></td></tr></table></figure></li>
<li>Time complexity: <span class="math inline">\(O(V + E)\)</span></li>
</ul></li>
<li>Edge classification
<ul>
<li>The edge in DFS can be classified into four types: tree edge, back
edge, forward edge and cross edge</li>
<li>Consider edge (u, v)
<ul>
<li>If v is visited for the first time (v.color is WHITE when (u,v) is
explored), then (u, v) is a tree edge</li>
<li>If v is an ancestor of u (v.color is GRAY when (u,v) is explored),
then (u, v) is a back edge</li>
<li>If v is a descendant of u but not a tree edge (v.color is BLACK and
u.i &lt; v.i), then (u, v) is a forward edge</li>
<li>If u is neither an ancestor nor a descendant of v (v.color is BLACK
and u.i &gt; v.i), then (u, v) is a cross edge</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-35-20220425">Lecture 35 2022/04/25</h2>
<ol type="1">
<li>Edge classification
<ul>
<li>Facts
<ul>
<li>If G is undirected, then there are only tree and back edges</li>
<li>If G is DAG <span class="math inline">\(\rightleftarrows\)</span>
DFS on G yields no back edges</li>
</ul></li>
<li>Cycle detection
<ul>
<li>A directed graph G contains a cycle if and only if a DFS of G yields
a back edge</li>
</ul></li>
</ul></li>
<li>Topological sort
<ul>
<li>A topological sort of a DAG is a linear ordering of all its vertices
such that if DAG contains an edge (u, v), then u appears before v in
ordering</li>
<li>Algorithm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">  call DFS(G) to compute the finishing times (u.f) of each vertex</span><br><span class="line">  when each vertex is finished (becomes BLACK in DFS-VISIT), insert it onto the front of a linked list</span><br><span class="line">  return the linked list</span><br></pre></td></tr></table></figure></li>
<li>Performance
<ul>
<li>Time complexity: <span class="math inline">\(O(V + E)\)</span></li>
<li>Space complexity: <span class="math inline">\(O(V + E)\)</span> (for
graph representation, recursion stack, and output list)</li>
</ul></li>
</ul></li>
</ol>
<h2 id="lecture-36-20220427">Lecture 36 2022/04/27</h2>
<ol type="1">
<li>Graph connectivity
<ul>
<li>Definition
<ul>
<li>Connected vertices: in an undirected graph G, two vertices u and v
are called connected if G contains a path from u to v. Otherwise, they
are called disconnected</li>
<li>Connected graph: a undirected graph is said to be connected if every
pair of vertices in the graph is connected. Otherwise, the graph is
disconnected
<ul>
<li>A graph consisting of one vertex is connected</li>
</ul></li>
<li>Connected component: if a undirected graph is not connected, then
each piece is called a connected component
<ul>
<li>If a graph is connected, then the thole graph is one single
connected component</li>
</ul></li>
<li>Connectivity for directed graph
<ul>
<li>Strongly connected: if there s a path in each direction between each
pair of vertices of a directed graph, then it is strongly connected</li>
<li>If a graph is not strongly connected, then it is weakly
connected</li>
</ul></li>
</ul></li>
</ul></li>
<li>Strongly connected components
<ul>
<li>A classical application of DFS is to decomposing a directed graph
into strongly connected components</li>
<li>Graph transpose/reverse: given a graph <span class="math inline">\(G
= (V, E)\)</span>, its transpose is <span class="math inline">\(G^{T} =
(V, E^{T})\)</span>, where <span class="math inline">\(E^{T} = \{(u, v)
| (v, u) \in E \}\)</span></li>
<li>Algorithm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED-COMPONENTS(G)</span><br><span class="line">  1. call DFS(G) to compute finished time u.f for each v in V</span><br><span class="line">  2. compute G^T (transpose of G)</span><br><span class="line">  3. call DFS(G^T), but in the main loop of DFS, consider the nodes in order of decreasing u.f (as computed in step 1)</span><br><span class="line">  4. output the vertices of each tree in the DFS forest of step 3 as a separate strongly connected component</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Minimum spanning tree
<ul>
<li>Definition
<ul>
<li>Spanning tree: a spanning tree is a subgraph that consists all the
vertices and is a tree</li>
<li>Minimum spanning tree: a spanning tree that has minimal total weight
of its edges is called a minimum spanning tree</li>
</ul></li>
<li>Algorithms: both greedy algorithms
<ul>
<li>Prim's algorithm</li>
<li>Kruskal's algorithm</li>
</ul></li>
</ul></li>
<li>P vs NP
<ul>
<li>P: the class of all problems that have an algorithm that can be
computed in polynomial time</li>
<li>NP: the class of all problems that can be verified in polynomial
time but may take an exponential time to solve
<ul>
<li>Some NP problems are P problems and can be solved in polynomial time
or less</li>
<li>The hardest NP problems are NP-complete, which have never been shown
to be solvable in polynomial time: e.g. the traveling salesman problem,
the hamiltonian cycle problem</li>
</ul></li>
<li>The problem is whether P = NP</li>
</ul></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Yanxuanshaozhu
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://yanxuanshaozhu.github.io/2022/01/22/COSI-21A-Data-Structures-and-Algorithms/" title="COSI 21A Data Structures and Algorithms">https://yanxuanshaozhu.github.io/2022/01/22/COSI-21A-Data-Structures-and-Algorithms/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Data-Structure/" rel="tag"># Data Structure</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/22/COSI-131A-Operating-System/" rel="prev" title="COSI 131A Operating System">
      <i class="fa fa-chevron-left"></i> COSI 131A Operating System
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/26/%E5%B2%A9%E6%B3%A2%E8%AC%9B%E5%BA%A7-%E6%97%A5%E6%9C%AC%E6%AD%B7%E5%8F%B2/" rel="next" title=" ">
        <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-01-20220119"><span class="nav-number">1.</span> <span class="nav-text">Lecture 01 2022&#x2F;01&#x2F;19</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-02-20220120"><span class="nav-number">2.</span> <span class="nav-text">Lecture 02 2022&#x2F;01&#x2F;20</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-03-20220124"><span class="nav-number">3.</span> <span class="nav-text">Lecture 03 2022&#x2F;01&#x2F;24</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-04-20210126"><span class="nav-number">4.</span> <span class="nav-text">Lecture 04 2021&#x2F;01&#x2F;26</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-05-20210127"><span class="nav-number">5.</span> <span class="nav-text">Lecture 05 2021&#x2F;01&#x2F;27</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-06-20210131"><span class="nav-number">6.</span> <span class="nav-text">Lecture 06 2021&#x2F;01&#x2F;31</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-07-20220202"><span class="nav-number">7.</span> <span class="nav-text">Lecture 07 2022&#x2F;02&#x2F;02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-08-20220203"><span class="nav-number">8.</span> <span class="nav-text">Lecture 08 2022&#x2F;02&#x2F;03</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-09-20220207"><span class="nav-number">9.</span> <span class="nav-text">Lecture 09 2022&#x2F;02&#x2F;07</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-10-20220209"><span class="nav-number">10.</span> <span class="nav-text">Lecture 10 2022&#x2F;02&#x2F;09</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-11-20220210"><span class="nav-number">11.</span> <span class="nav-text">Lecture 11 2022&#x2F;02&#x2F;10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-12-20220214"><span class="nav-number">12.</span> <span class="nav-text">Lecture 12 2022&#x2F;02&#x2F;14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-13-20220216"><span class="nav-number">13.</span> <span class="nav-text">Lecture 13 2022&#x2F;02&#x2F;16</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-14-20220217"><span class="nav-number">14.</span> <span class="nav-text">Lecture 14 2022&#x2F;02&#x2F;17</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-15-20220228"><span class="nav-number">15.</span> <span class="nav-text">Lecture 15 2022&#x2F;02&#x2F;28</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-16-20220302"><span class="nav-number">16.</span> <span class="nav-text">Lecture 16 2022&#x2F;03&#x2F;02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-17-20220303"><span class="nav-number">17.</span> <span class="nav-text">Lecture 17 2022&#x2F;03&#x2F;03</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-18-20220307"><span class="nav-number">18.</span> <span class="nav-text">Lecture 18 2022&#x2F;03&#x2F;07</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-19-20220309"><span class="nav-number">19.</span> <span class="nav-text">Lecture 19 2022&#x2F;03&#x2F;09</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-20-20220310"><span class="nav-number">20.</span> <span class="nav-text">Lecture 20 2022&#x2F;03&#x2F;10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-21-20220316"><span class="nav-number">21.</span> <span class="nav-text">Lecture 21 2022&#x2F;03&#x2F;16</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-22-20220317"><span class="nav-number">22.</span> <span class="nav-text">Lecture 22 2022&#x2F;03&#x2F;17</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-23-20220321"><span class="nav-number">23.</span> <span class="nav-text">Lecture 23 2022&#x2F;03&#x2F;21</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-24-20220323"><span class="nav-number">24.</span> <span class="nav-text">Lecture 24 2022&#x2F;03&#x2F;23</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-25-20220324"><span class="nav-number">25.</span> <span class="nav-text">Lecture 25 2022&#x2F;03&#x2F;24</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-26-20220328"><span class="nav-number">26.</span> <span class="nav-text">Lecture 26 2022&#x2F;03&#x2F;28</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-27-20220330"><span class="nav-number">27.</span> <span class="nav-text">Lecture 27 2022&#x2F;03&#x2F;30</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-28-20220331"><span class="nav-number">28.</span> <span class="nav-text">Lecture 28 2022&#x2F;03&#x2F;31</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-29-20220404"><span class="nav-number">29.</span> <span class="nav-text">Lecture 29 2022&#x2F;04&#x2F;04</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-30-20220406"><span class="nav-number">30.</span> <span class="nav-text">Lecture 30 2022&#x2F;04&#x2F;06</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-31-20220407"><span class="nav-number">31.</span> <span class="nav-text">Lecture 31 2022&#x2F;04&#x2F;07</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-32-20220411"><span class="nav-number">32.</span> <span class="nav-text">Lecture 32 2022&#x2F;04&#x2F;11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-33-20220413"><span class="nav-number">33.</span> <span class="nav-text">Lecture 33 2022&#x2F;04&#x2F;13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-34-20220414"><span class="nav-number">34.</span> <span class="nav-text">Lecture 34 2022&#x2F;04&#x2F;14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-35-20220425"><span class="nav-number">35.</span> <span class="nav-text">Lecture 35 2022&#x2F;04&#x2F;25</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lecture-36-20220427"><span class="nav-number">36.</span> <span class="nav-text">Lecture 36 2022&#x2F;04&#x2F;27</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanxuanshaozhu"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yanxuanshaozhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanxuanshaozhu" title="GitHub  https:&#x2F;&#x2F;github.com&#x2F;yanxuanshaozhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mrlixm.cn@gmail.com" title="E-Mail  mailto:mrlixm.cn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanxuanshaozhu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">26:43</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
