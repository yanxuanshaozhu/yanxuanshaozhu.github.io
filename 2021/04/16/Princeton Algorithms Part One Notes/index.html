<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yanxuanshaozhu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Course Name: Algorithms, Part I   Course Website: Coursera  Instructor: Professor Kevin Wayne, Professor Robert Sedgewick   Books: Algorithms(4th edition)">
<meta property="og:type" content="article">
<meta property="og:title" content="Princeton Algorithms Part One Notes">
<meta property="og:url" content="https://yanxuanshaozhu.github.io/2021/04/16/Princeton%20Algorithms%20Part%20One%20Notes/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="Course Name: Algorithms, Part I   Course Website: Coursera  Instructor: Professor Kevin Wayne, Professor Robert Sedgewick   Books: Algorithms(4th edition)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/CourseStructure.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/UFPerformance.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/PathCompression1.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/PathCompression2.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/UFSummary.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/Percolation.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/ThresholdPercolation.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/Stability.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/SortSummary1.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/SortSummary2.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/RBT3Node.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/BST1NodeInsertion.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/BST2NodeInsertion.pngs">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/BSTPerformance.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/SeparateChaining.png">
<meta property="og:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/LinearProbing.png">
<meta property="article:published_time" content="2021-04-16T13:12:53.000Z">
<meta property="article:modified_time" content="2021-05-23T09:21:34.781Z">
<meta property="article:author" content="Yanxuanshaozhu">
<meta property="article:tag" content="Algorithm Part One">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yanxuanshaozhu.github.io/images/Algorithm/CourseStructure.png">

<link rel="canonical" href="https://yanxuanshaozhu.github.io/2021/04/16/Princeton%20Algorithms%20Part%20One%20Notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Princeton Algorithms Part One Notes | My Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">My Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">20</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yanxuanshaozhu.github.io/2021/04/16/Princeton%20Algorithms%20Part%20One%20Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Yanxuanshaozhu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Princeton Algorithms Part One Notes
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-16 21:12:53" itemprop="dateCreated datePublished" datetime="2021-04-16T21:12:53+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-05-23 17:21:34" itemprop="dateModified" datetime="2021-05-23T17:21:34+08:00">2021-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>73k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:06</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p style="text-align:left; font-weight:bold;">
Course Name: Algorithms, Part I
</p>
<p><a style="text-align:left; font-weight:bold;" target="_blank" rel="noopener" href="https://www.coursera.org/learn/algorithms-part1"> Course Website: Coursera</a></p>
<p style="text-align:left; font-weight:bold;">
Instructor: Professor Kevin Wayne, Professor Robert Sedgewick
</p>
<p style="text-align:left; font-weight:bold;">
Books: Algorithms(4th edition)
</p>
<a id="more"></a>
<h1 id="week-1">Week 1</h1>
<ol type="1">
<li>Introduction
<ul>
<li>Course Structure: <img src="/images/Algorithm/CourseStructure.png"></li>
</ul></li>
<li>Analysis of Algorithms
<ul>
<li>Introduction
<ul>
<li>Running time is the key concern</li>
<li>Reasons to analyze algorithms:
<ul>
<li>Predict performance</li>
<li>Compare algorithms</li>
<li>Provide guarantees</li>
<li>Understand theoretical basis</li>
</ul></li>
<li>Scientific method applied to analysis of algorithms
<ul>
<li>observe =&gt; hypothesize =&gt; predict =&gt; verify =&gt; validate</li>
<li>Experiments must be reproducible, hypotheses must be falsifiable</li>
</ul></li>
</ul></li>
<li>Observations
<ul>
<li>Use plots to analyze algorithms:
<ul>
<li>Standard plot: <code>(problem size N, running time T(n))</code></li>
<li>Log-log plot: <code>(lgN, lgT(N))</code></li>
</ul></li>
<li>Factors affecting algorithm performance
<ul>
<li>System independent effects: algorithm, input</li>
<li>System dependent effects: hardware, software, system</li>
</ul></li>
</ul></li>
<li>Mathematical Models
<ul>
<li>Total running time: sum of cost * frequency for all operations</li>
<li>Simplification
<ul>
<li>Cost model: use some basic operation as a proxy for running time</li>
<li>Tilde notation: estimate running time as a function of input size N, and ignore lower order terms <span class="math display">\[1 + 2 + ... + N  = \sum_{i = 1}^{N} i  \sim \int_{x = 1}^{N} xdx \sim  \frac{1}{2}N^{2}\]</span> <span class="math display">\[1 + \frac{1}{2} + ... + \frac{1}{N}  = \sum_{i = 1}^{N} \frac{1}{i}  \sim \int_{x = 1}^{N} \frac{1}{x}dx \sim  lnN\]</span> <span class="math display">\[\sum_{i = 1}^{N}\sum_{j = 1}^{N}\sum_{k = 1}^{N} 1  \sim \int_{x = 1}^{N} \int_{y = 1}^{N}\int_{z = 1}^{N}dxdydz \sim \frac{1}{6}N^{3}\]</span></li>
</ul></li>
<li>In general, $T_{N} = c_{1}A +c_{1}A + c_{2}B + c_{3}C + c_{4}D + c_{5}E $, where A = array access, B = integer add, C = integer compare, D = increment, E = variable assignment</li>
</ul></li>
<li>Order of Growth Classification
<ul>
<li>Order-of-growth of typical algorithms: <span class="math inline">\(1(constant)\)</span>, <span class="math inline">\(logN(logarithmic)\)</span>, <span class="math inline">\(N(linear)\)</span>, <span class="math inline">\(NlogN(linearithmic)\)</span>, <span class="math inline">\(n^{2}(quadratic)\)</span>, <span class="math inline">\(N^{3}(cubic)\)</span>, <span class="math inline">\(2^{N}(exponential)\)</span></li>
</ul></li>
<li>Theory of Algorithms
<ul>
<li>Types of analyses
<ul>
<li>Best case: lower bound on cost, determined by easiest input, provides a goal for all inputs</li>
<li>Worst case: upper bound on cost, determined by most difficult input, provides a guarantee for all inputs</li>
<li>Average case: expected cost for random input, need a model for random input, provides a way to predict performance</li>
</ul></li>
<li>Theory of algorithms
<ul>
<li>Goals: establish difficulty of a problem, develop optimal algorithms</li>
<li>Approach: suppress details in analysis, eliminate variability in input by focusing on the worst case</li>
<li>Optimal algorithm: performance guarantee for any input, no algorithm can provide a better performance guarantee</li>
<li>Commonly-used notations:
<ul>
<li>Big Theta: asymptotic order of growth, <span class="math inline">\(\Theta(f(N))\)</span></li>
<li>Big Oh: <span class="math inline">\(\Theta(f(N))\)</span> and smaller, <span class="math inline">\(O(f(N))\)</span></li>
<li>Big Omega: <span class="math inline">\(\Theta(f(N))\)</span> and larger, <span class="math inline">\(\Omega(f(N))\)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li>Memory
<ul>
<li>Basics
<ul>
<li>Bit: 0,1; byte: 8 bits; MB: 1million or <span class="math inline">\(2^{30}\)</span> bytes; GB: 1 billion or <span class="math inline">\(2^{30}\)</span> bytes</li>
<li>Old machine: a 32-bit machine with 4 byte pointers</li>
<li>Modern machine: a 64-bit machine with 8 byte pointers</li>
</ul></li>
<li>Object memory usage:
<ul>
<li>boolean: 1 byte; byte: 1 byte; char: 2 bytes; int: 4 bytes; float: 4 bytes; long: 8 bytes; double: 8 bytes</li>
<li>One-dimensional arrays: char[]: 2N + 24 bytes; int[]: 4N + 24 bytes; double[]: 8N + 24 bytes</li>
<li>Two-dimensional arrays: char[][]: ~ 2MN bytes; int[][]: ~ 4MN bytes; double[][]: ~ 8MN bytes</li>
<li>Object overhead: 16 bytes</li>
<li>Reference: 8 bytes</li>
<li>Padding: each object uses a multiple of 8 bytes</li>
</ul></li>
</ul></li>
</ul></li>
<li>Union Find
<ul>
<li>Dynamic Connectivity
<ul>
<li>Problem description
<ul>
<li>Given a set of N objects, we can union two objects by connecting them. Two objects are connected if there is a path through which you can travel from one point to another. What we want to know is that given two objects in the set, whether they are connected or not.</li>
</ul></li>
<li>Application: pixels in a digital photo, computers in a network, friends in a social network, variable names in a program, etc.</li>
<li>Equivalence relation of the connectivity:
<ul>
<li>Reflexive: p is connected to p</li>
<li>Symmetric: if p is connected to q, then q is connected to p</li>
<li>Transitive: if p is connected to q, and q is connected to r, then p is connected to r</li>
</ul></li>
<li>Connected components: maximal set of objects that are mutually connected</li>
</ul></li>
<li>Quick Find
<ul>
<li>It's an eager algorithm to solve the dynamic connectivity problem</li>
<li>Data structure description
<ul>
<li>The data structure is an integer array <code>id[]</code> of size N， each entry is the id that represents the connected component to which this point belongs</li>
<li>Connected command: if two points have the same id, then they are connected</li>
<li>Union command: when union point <code>p</code> to point <code>q</code>, change all elements whose id equals to <code>id[p]</code> to <code>id[q]</code></li>
</ul></li>
<li>Algorithm <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickFindUF</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">QuickFindUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    id = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id[p] == id[q];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idp = id[p];</span><br><span class="line">    <span class="keyword">int</span> idq = id[q];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (id[i] == idp) &#123;</span><br><span class="line">        id[i] = idq;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Performance analysis: N union objects on N objects takes quadratic time, which is quite unbearable fo large datasets</li>
</ul></li>
<li>Quick Union
<ul>
<li>It's a lazy approach to solve the dynamic connectivity problem</li>
<li>Data structure description
<ul>
<li>The data structure is an integer array <code>id[]</code> of size N, each entry is the id that represents the parent point of the current point. All points construct a forest containing connected trees and unconnected leaves</li>
<li>Root of the tree containing point <code>i</code> is <code>id[id[id[...id[i]...]]]</code></li>
<li>Connected command: if two points have the same root, then they are connected</li>
<li>Union command: when union point <code>p</code> to point <code>q</code>, set the parent of p's root be q's root</li>
</ul></li>
<li>Algorithm <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUnionUF</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">QuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != id[node]) &#123;</span><br><span class="line">      node = id[node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root(p) == root(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootp = root(p);</span><br><span class="line">    <span class="keyword">int</span> rootq = root(q);</span><br><span class="line">    id[rootp] = rootq;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Performance analysis: trees can be too tall, then find command can be slow since it's a linear operation</li>
</ul></li>
<li>Quick Union Improvement
<ul>
<li>Improvement 1: Weighting
<ul>
<li>Keep track of size of each tree, and balance by linking root of smaller tree to root of larger tree in union command. When there are equal size trees, put the former tree under the latter tree</li>
<li>Data structure description: same as quick union, but maintain extra array <code>size[i]</code> to count number of objects in the tree rooted at <code>i</code></li>
<li>Find command: identical to quick union</li>
<li>Union link root of smaller tree to root of larger tree, update the size[] array <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> rootp = root(p);</span><br><span class="line">  <span class="keyword">int</span> rootq = root(q);</span><br><span class="line">  <span class="keyword">if</span> (size(rootp) &lt;= size(rootq)) &#123;</span><br><span class="line">    id[rootp] = rootq;</span><br><span class="line">    size[rootq] += size[rootp];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    id[rootq] = rootp;</span><br><span class="line">    size[rootp] += size[rootq];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Theorem: depth of any node x is at most lgN</li>
<li>Performance analysis <img src="/images/Algorithm/UFPerformance.png"></li>
</ul></li>
<li>Improvement 2: Path Compression
<ul>
<li>Idea: after computing the root of p, set the id of each examined node to point to that root, so that the tree is flattened <img src="/images/Algorithm/PathCompression1.png"> Convert the above tree into the following one <img src="/images/Algorithm/PathCompression2.png"></li>
<li>Java implementation
<ul>
<li>Two-pass implementation: add a second loop to <code>root()</code> to set the <code>id[]</code> of each examined node to the root</li>
<li>Simpler one-pass variant: make every other node in path point to its grandparent <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (node != id[node]) &#123;</span><br><span class="line">    id[node] = id[id[node]];</span><br><span class="line">    node = id[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Theorem: starting from an empty data structure, any sequence of M union-find operations on N objects makes <span class="math inline">\(\leq c(N + M lgN)\)</span> array accesses. Actually there is no linear algorithm for the union find problem</li>
</ul></li>
<li>Summary <img src="/images/Algorithm/UFSummary.png"></li>
</ul></li>
<li>Union Find Application
<ul>
<li>There are many applications for the union find problem</li>
<li>Percolation
<ul>
<li>It's a model for many physical systems</li>
<li>There is N-by-N grid of sites, each site is open with probability <span class="math inline">\(p\)</span> or blocked with probability <span class="math inline">\(1 - p\)</span>. The system percolates iff the top and bottom are connected by open sites <img src="/images/Algorithm/Percolation.png"></li>
<li>Likelihood of percolation
<ul>
<li><p>When N is large, theory guarantees a sharp threshold <span class="math inline">\(p^{*}\)</span></p>
<p>If <span class="math inline">\(p \ge p^{*}\)</span>: almost certainly percolates</p>
<p>If <span class="math inline">\(p \le p^{*}\)</span>: almost certainly does not percolate <img src="/images/Algorithm/ThresholdPercolation.png"></p></li>
<li><p>No analytical solution of <span class="math inline">\(p^{*}\)</span> could be found, but it could be estimated using Monte Carlo simulation</p>
<ol type="1">
<li>Initialize N-by-N whole grid to be blocked</li>
<li>Declare random sites open until top connected to bottom</li>
<li>Vacancy percentage estimates <span class="math inline">\(p^{*}\)</span></li>
</ol></li>
<li><p>We can use dynamic connectivity to estimate the percolation threshold. For <span class="math inline">\(N = 100\)</span>, the estimated <span class="math inline">\(p^{*} \approx 0.592746\)</span></p></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h1 id="week-2">Week 2</h1>
<ol type="1">
<li>Stacks and Queues
<ul>
<li>Fundamental data types:
<ul>
<li>Value: collection of objects</li>
<li>Operations: insert, remove, iterate, test if empty</li>
<li>Stack: LIFO, insert is called push, remove is called pop</li>
<li>Queue: FIFO, insert is called enqueue, remove is called dequeue</li>
<li>Module programming: completely separate interface and implementation</li>
</ul></li>
<li>Stack
<ul>
<li>Stack API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOfStrings</span> </span>&#123;</span><br><span class="line">  StackOfStrings() </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span></span></span><br><span class="line"><span class="function">  String <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>LinkedList Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String item;</span><br><span class="line">    Node next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String item = first.item;</span><br><span class="line">    first = first.next;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    Node oldFirst = first;</span><br><span class="line">    first = <span class="keyword">new</span> Node();</span><br><span class="line">    first.item = item;</span><br><span class="line">    first.next = oldFirst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Every operation takes constant time in the worst case</li>
</ul></li>
<li>Array Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N ==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    items[N++] = item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Loitering</span></span><br><span class="line"><span class="comment">  public String pop() &#123;</span></span><br><span class="line"><span class="comment">    return items[--N];</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String item = items[--N];</span><br><span class="line">    items[N] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> item; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Don't address underflow(pop with an empty stack) and overflow(push with a full stack)</li>
<li>Loitering: holding a reference to an object when it is no longer needed</li>
</ul></li>
</ul></li>
<li>Resizing Arrays
<ul>
<li><p>First try: change size by 1 for push and pop</p>
<ul>
<li>It's too expensive, you need to copy all items to the new array. In order to insert <span class="math inline">\(N\)</span> items into an empty stack, it costs <span class="math inline">\(N^2\)</span> time(To insert into a full stack with <span class="math inline">\(k\)</span> size, you need to create a <span class="math inline">\(k + 1\)</span> array and copy all items, so that's <span class="math inline">\(1 + ... + N \sim N^2\)</span>)</li>
</ul></li>
<li><p>Repeated doubling: double array size when full, halve array size when one-quarterfull <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">private</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == items.length) &#123;</span><br><span class="line">      resize(<span class="number">2</span> * items.length);</span><br><span class="line">    &#125;</span><br><span class="line">    items[N++] = item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String item = items[--N];</span><br><span class="line">    items[N] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>  (N &gt; <span class="number">0</span> &amp;&amp; N == items.length /<span class="number">4</span>) &#123;</span><br><span class="line">      resize(items.length / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    String[] copy = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      copy[i] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    items = copy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>To insert N items into an empty array, it costs <span class="math inline">\(N + 2 + 4 + ... + N \sim 3N\)</span></li>
<li>Amortized analysis: average running time per operation over a worst-case sequence of operations</li>
<li>Starting from an empty stack, any sequence of <span class="math inline">\(M\)</span> push and pop operations takes time proportional to <span class="math inline">\(M\)</span></li>
<li>LinkedList v.s. resizing array for stack implementation
<ul>
<li>LinkedList: every operation takes constant time in the worst case, use extra time and space to deal with the links</li>
<li>Resizing-array: every operation takes constant amortized time, less wasted space</li>
</ul></li>
</ul></li>
</ul></li>
<li>Queues
<ul>
<li>Queue API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueOfStrings</span> </span>&#123;</span><br><span class="line">  QueueOfStrings()</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String item)</span></span></span><br><span class="line"><span class="function">  String <span class="title">dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>LinkedList Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line"> <span class="keyword">private</span> Node last;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    String item;</span><br><span class="line">    Node next;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String item = first.item;</span><br><span class="line">    first = first.next;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      last = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    Node oldLast = last;</span><br><span class="line">    last = <span class="keyword">new</span> Node();</span><br><span class="line">    last.item = item;</span><br><span class="line">    last.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      first = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      oldLast.next = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Resizing Array Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rear - front == items.length) &#123;</span><br><span class="line">      resize(<span class="number">2</span> * items.length);</span><br><span class="line">    &#125;</span><br><span class="line">    items[rear] = item;</span><br><span class="line">    rear += <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String item = items[front];</span><br><span class="line">    items[front] = <span class="keyword">null</span>;</span><br><span class="line">    front += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( rear - front &gt; <span class="number">0</span> &amp;&amp; rear - front == items.length / <span class="number">4</span>) &#123;</span><br><span class="line">      resize(items.length / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    String[] copy = <span class="keyword">new</span> String[capacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rear - front; i++) &#123;</span><br><span class="line">      copy[i] = items[front + i];</span><br><span class="line">    &#125;</span><br><span class="line">    items = copy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Generics
<ul>
<li>Collections that can contain various types data
<ul>
<li>Implement a separate collection class for each type: tedious</li>
<li>Implement a collection for object type and use type casting like: Object variable = new Object(); T target = (T) variable</li>
<li>Implement a collection with generics: avoid casting when using collections, discover type mismatch errors at compile-time rather than run-time</li>
</ul></li>
<li>LinkedList Stack with Generics <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStackGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">    Node next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    Node oldFirst = first;</span><br><span class="line">    first = <span class="keyword">new</span> Node();</span><br><span class="line">    first.item = item;</span><br><span class="line">    first.next = oldFirst;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T item = first.item;</span><br><span class="line">    first = first.next;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first == <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ArrayStack with Generics <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStackGeneric</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// It&#x27;s not allowed in java to create generic arrays, you need type casting here</span></span><br><span class="line">    s = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N ==<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    items[N++] = item;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T item = items[--N];</span><br><span class="line">    items[N] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Autoboxing
<ul>
<li>For each primitive type there is a wrapper object type, automatic cast ca be done between primitive type and wrapper type</li>
<li>You need to use wrapper types rather than primitive types in collections</li>
<li>Convert from String to other type: <code>int aInt = Integer.parseInt("aString");</code></li>
</ul></li>
</ul></li>
</ul></li>
<li>Iterators
<ul>
<li>Java supports iteration over stack items by client, without revealing the internal representation of the collections</li>
<li>Iterable: a interface that has a method that returns an Iterator <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Iterator: an interface that has methods <code>hasNext()</code> and <code>next()</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Java supports elegant enhanced-for loop with iterable data structures <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String element: stack) &#123;</span><br><span class="line">  System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LinkedList Stack with Iterator <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node current = first;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> current != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      T item = current.item;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Array List Stack with Iterator <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = N;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> items[--i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Bag
<ul>
<li>Application: adding items to a collection and iterating, order doesn't matter</li>
<li>Bag API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  Bag();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Stack and Queue Applications
<ul>
<li>Java collections library
<ul>
<li>List
<ul>
<li>List interface: <code>java.util.List: public interface List&lt;E&gt; extends Collection&lt;E&gt;</code></li>
<li>Implementations: <code>java.util.ArrayList: public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code>, <code>java.util.LinkedList: public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></li>
</ul></li>
<li>Stack: <code>java.util.Stack: public class Stack&lt;E&gt; extends Vector&lt;E&gt;</code></li>
<li>Queue: <code>java.util.Queue: public interface Queue&lt;E&gt; extends Collection&lt;E&gt;</code></li>
</ul></li>
<li>Stack applications:
<ul>
<li>Parsing in a complier
<ul>
<li>Dijkstra's two-stack algorithm
<ul>
<li>Operand: push into the operand stack</li>
<li>Operator: push into the operator stack</li>
<li>Left parenthesis: ignore</li>
<li>Right parenthesis: pop operator and two operands, calculate, push the result into the operand stack</li>
</ul></li>
</ul></li>
<li>Java virtual machine</li>
<li>Undo in a word processor</li>
<li>Back button in a web browser</li>
<li>...</li>
</ul></li>
</ul></li>
<li>Problems
<ul>
<li>Create a queue using two stack <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You should not use java.util.Stack, you should use java.util.Deque instead:</span></span><br><span class="line"><span class="comment">// A more complete and consistent set of LIFO stack operations is provided by the  </span></span><br><span class="line"><span class="comment">// Deque interface and its implementations, which should be used in preference to this class. </span></span><br><span class="line"><span class="comment">//Space complexity: O(N), time complexity: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  Deque&lt;Integer&gt; out, in;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      in = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">      out = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!out.isEmpty()) &#123;</span><br><span class="line">        in.addLast(out.pollLast());</span><br><span class="line">      &#125;</span><br><span class="line">      in.addLast(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">        out.addLast(in.pollLast());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out.pollLast();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">        out.addLast(in.pollLast());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out.peekLast();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> out.isEmpty() &amp;&amp; in.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Time complexity: amortized O(1), space complexity: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">  Deque&lt;Integer&gt; out, in;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      in = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">      out = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      in.addLast(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">            out.addLast(in.pollLast());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out.pollLast();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">            out.addLast(in.pollLast());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> out.peekLast();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> out.isEmpty() &amp;&amp; in.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>Max/Min Stack: use another stack to trace the max/min value</li>
</ul></li>
</ul></li>
<li>Elementary Sorts
<ul>
<li>Sorting Introduction
<ul>
<li>Callbacks
<ul>
<li>Goal: sort any type of data</li>
<li>Client passes array of objects to <code>sort()</code> function, the sort function calls back object's <code>compareTo()</code> method as needed</li>
</ul></li>
<li>Implementing callbacks
<ul>
<li>Java: interface <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Item that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// v.compareTo(w) returns negative integer, zero, or positive if v &lt; w, v == w, or v &gt; w</span></span><br><span class="line"><span class="comment">// if v and w are not comparable, throws an Exception</span></span><br></pre></td></tr></table></figure></li>
<li>C: function pointers</li>
<li>C++: class-type pointers</li>
<li>Python, Perl, Javascript: first-class functions</li>
</ul></li>
<li>Total order:
<ul>
<li>Antisymmetry: if <span class="math inline">\(v \leq w\)</span> and <span class="math inline">\(w \leq v\)</span>, then <span class="math inline">\(v = w\)</span></li>
<li>Transitivity: if <span class="math inline">\(v \leq w\)</span> and <span class="math inline">\(w \leq x\)</span>, then <span class="math inline">\(v \leq x\)</span></li>
<li>Totality: either <span class="math inline">\(v \leq w\)</span> or <span class="math inline">\(w \leq v\)</span> or both</li>
</ul></li>
</ul></li>
<li>Selection Sort
<ul>
<li>Idea to get an ascending array
<ul>
<li>In iteration i, find index <code>min</code> of smallest remaining entry</li>
<li>Swap <code>array[i]</code> and <code>array[min]</code></li>
<li>The part on the left side of i is an invariant, that is, the entries are sorted</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = items.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> min = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[j].compareTo(items[min]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          min = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Comparable item = items[min];</span><br><span class="line">      items[min] = items[i];</span><br><span class="line">      items[i] = item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>For an array with size <span class="math inline">\(N\)</span>, selection sort takes about <span class="math inline">\(\frac{N^2}{2}\)</span> comparisons and about <span class="math inline">\(N\)</span> exchanges. No matter whether the input is sorted or totally unsorted, the complexity of selection sort is always quadratic</li>
</ul></li>
<li>Insertion Sort
<ul>
<li>Idea to get an ascending array
<ul>
<li>In iteration i, swap <code>array[i]</code> with each larger entry to its left</li>
<li>The part on the left side of i is an invariant, that is, the entries are sorted</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = items.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; items[j].compareTo(items[j - <span class="number">1</span>]) &lt; <span class="number">0</span>; j--) &#123;  </span><br><span class="line">          Comparable item = items[j];</span><br><span class="line">          items[j] = items[i];</span><br><span class="line">          items[i] = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>For a randomly-ordered array with <span class="math inline">\(N\)</span> distinct keys, insertion sort uses about <span class="math inline">\(\frac{N^2}{4}\)</span> comparisons and about <span class="math inline">\(\frac{N^2}{4}\)</span> exchanges on average.</li>
<li>For an ordered array, insertion sort makes <span class="math inline">\(N - 1\)</span> comparisons and <span class="math inline">\(0\)</span> exchanges</li>
<li>For an reversely-ordered array, insertion sort makes about <span class="math inline">\(\frac{N^2}{2}\)</span> comparisons and about <span class="math inline">\(\frac{N^2}{4}\)</span> exchanges</li>
</ul></li>
<li>Shell Sort
<ul>
<li>Idea to get an ascending array
<ul>
<li>Move entries more than one position at a time by h-sorting the array</li>
<li>Use insertion sort in h-sorting: for large h, the subarray is small, so sorting can be fast, for small h, the array is nearly sorted, to insertion sort is fast</li>
<li>A m-sorted array is still m-sorted after being n-sorted</li>
<li>The general chosen h is <span class="math inline">\(h = 3 * h + 1\)</span></li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = items.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N /<span class="number">3</span>) &#123;</span><br><span class="line">      h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; items[j].compareTo(items[j - h]) &lt; <span class="number">0</span>; j -= h) &#123;</span><br><span class="line">          Comparable item = items[j];</span><br><span class="line">          items[j] = items[j - h];</span><br><span class="line">          items[j - h] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>The worst-case number of comparisons used by shell sort with <span class="math inline">\(3 * h + 1\)</span> increments is <span class="math inline">\(O(N^{\frac{3}{2}})\)</span></li>
<li>Shell sort is faster than selection sort and insertion sort, the larger the array is, the better the performance is</li>
</ul></li>
<li>Shuffling Sort
<ul>
<li>Initial idea to get a randomized shuffle of an array
<ul>
<li>Generate a random real number for each array entry</li>
<li>Sort the array</li>
</ul></li>
<li>Shuffle sort produces a uniformly random permutation of the input array, provided no duplicate values</li>
<li>Knuth shuffle in linear time
<ul>
<li>In iteration i, pick integer r between 0 and i uniformly at random</li>
<li>Swap <code>array[r]</code> and <code>array[i]</code></li>
<li>The part on the left side of i is an invariant, that is, the entries are uniformly randomized</li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuffleSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = items.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = StdRandom.uniform(i + <span class="number">1</span>); <span class="comment">// Uniform random number in [0, i]</span></span><br><span class="line">      Comparable item = items[r];</span><br><span class="line">      items[r] = items[i];</span><br><span class="line">      items[i] = item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Convex Hull
<ul>
<li>Some equivalent definitions of a convex hull
<ul>
<li>The smallest perimeter fence enclosing a set of points</li>
<li>The smallest convex set containing all the points</li>
<li>The smallest area convex polygon enclosing the points</li>
<li>The convex polygon enclosing the points, whose vertices are points in set</li>
</ul></li>
<li>Output: sequence of vertices in counterclockwise order</li>
<li>Fact
<ul>
<li>Can traverse the convex hull by making only counterclockwise turns</li>
<li>The vertices of convex hull appear in increasing order of polar angle with respect to point p with lowest y-coordinate</li>
</ul></li>
<li>Graham Scan
<ul>
<li>Choose point p with smallest y-coordinate</li>
<li>Sort points by polar angle with p</li>
<li>Consider points in order, discard unless it creates a counterclockwise turn</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h1 id="week-3">Week 3</h1>
<ol type="1">
<li>Merge Sort
<ul>
<li>Introduction
<ul>
<li>Two classic sorting algorithm
<ul>
<li>Merge sort: java sort for objects, Perl, C stable sort, Python stable sort, Firefox javascript, ...</li>
<li>Quick sort: java sort for primitive types, C qsort, Unix, C++, Python, Matlab, Chrome javascript, ...</li>
</ul></li>
<li>Idea is divide and conquer
<ul>
<li>Divide the array into two halves</li>
<li>Recursively sort each half</li>
<li>Merge the two halves using an auxiliary array</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];     <span class="comment">// Do not create aux in the private recursive sorts</span></span><br><span class="line">    sort(items, <span class="number">0</span>, items.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(items, lo, mid);</span><br><span class="line">    sort(items, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(items, lo, mid, hi);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isSorted(items, lo, mid);</span></span><br><span class="line">    <span class="comment">// assert isSorted(items, mid + 1, hi);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">      aux[i] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = lo; j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">        items[k] = aux[j++];              <span class="comment">// items[lo...mid] has already been copied</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">        items[k] = items[i++];              <span class="comment">// items[mid + 1...hi] has already been copied</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[j].compareTo(aux[i]) &lt; <span class="number">0</span>) &#123;              </span><br><span class="line">        items[k] = aux[j++];                  <span class="comment">// For stability reason, we cannot revert this else if statement and the else statement</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[k] = aux[i++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// assert isSorted(items, lo, hi)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>Facts
<ul>
<li>Merge sort uses at most <span class="math inline">\(NlogN\)</span> comparisons and <span class="math inline">\(6NlogN\)</span> array access to sort any array of size <span class="math inline">\(N\)</span>. If <span class="math inline">\(D(N)\)</span> satisfies <span class="math inline">\(D(N) = 2D(\frac{N}{2}) + N\)</span> for <span class="math inline">\(N &gt; 1\)</span>, with <span class="math inline">\(D(1) = 0\)</span>, then <span class="math inline">\(D(N) = N logN\)</span></li>
<li>Merge sort uses extra space proportional to <span class="math inline">\(N\)</span></li>
<li>A sorting algorithm is in-place if it uses <span class="math inline">\(\leq clogN\)</span> extra memory. Ex. insertion sort, selection sort, shell sort. Merge sort can be in-place, [Kronrod, 1969]</li>
</ul></li>
<li>Improvements
<ul>
<li>Merge sort is recursive, so it will be slow for small subarrays, we can use insertion sort for small subarrays <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> FUTOFF = <span class="number">7</span>;       <span class="comment">// you can set your own cutoff to decide how small is an small array</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hi &lt;= lo + CUTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">    InsertionSort.sort(items, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">  sort(items, aux, lo, mid);</span><br><span class="line">  sort(items, aux, mid + <span class="number">1</span>, hi);</span><br><span class="line">  merge(items, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>If <code>items[mid] &lt;= items[mid + 1]</code>, then don't need to merge, the whole array is already sorted <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hi &lt;= lo + CUTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">    InsertionSort.sort(items, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">  sort(items, aux, lo, mid);</span><br><span class="line">  sort(items, aux, mid + <span class="number">1</span>, hi);</span><br><span class="line">  <span class="keyword">if</span> (items[mid].compareTo(items[mid + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  merge(items, aut, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Eliminate the copy to the auxiliary array <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] items, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = lo; </span><br><span class="line">  <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; mid) &#123;+</span><br><span class="line">      aux[k] = items[j++]              </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">      aux[k] = items[i++]              </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (items[j].compareTo(items[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      aux[k] = items[j++]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      aux[k] = items[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hi &lt;= lo + CUTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">    InsertionSort.sort(items, lo, hi);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid = lo + (high - lo) / <span class="number">2</span>;</span><br><span class="line">  sort(aux, items, lo, mid);</span><br><span class="line">  sort(aux, items, mid + <span class="number">1</span>, hi);</span><br><span class="line">  <span class="keyword">if</span> (aux[mid].compareTo(aux[mid + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  merge(aux, items, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Bottom-up Merge Sort
<ul>
<li>No recursion needed plan
<ul>
<li>Pass through array, merging subarrays of size 1</li>
<li>Repeat for subarrays of size 2, 4, 6, 8, 16, ..., array.length</li>
</ul></li>
<li>Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo; </span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">        items[k] = aux[j++];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">        items[k] = aux[i++];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[j].compareTo(aux[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        items[k] = aux[j++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        items[k] = aux[i++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = items.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz *= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz * <span class="number">2</span>) &#123;</span><br><span class="line">        merge(items, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz * <span class="number">2</span> - <span class="number">1</span>, N -<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Sorting Complexity
<ul>
<li>Complexity of sorting
<ul>
<li>Computational complexity: framework to study efficiency of algorithms for solving a particular problem X</li>
<li>Model of computation: allowable operations</li>
<li>Cost model: operation counts</li>
<li>Upper bound: cost guarantee provided by some algorithm for X</li>
<li>Lower bound: proven limit on cost guarantee of all algorithms for X</li>
<li>Optimal algorithm: algorithm with best possible cost guarantee for X</li>
<li>Sorting Ex.
<ul>
<li>Model of computation: decision tree
<ul>
<li>The height of the tree is the worst-case number of comparisons</li>
<li>There is at least one leaf for each possible ordering</li>
</ul></li>
<li>Cost model: number of comparisons</li>
<li>Upper bound: about <span class="math inline">\(NlogN\)</span> from merge sort</li>
<li>Lower bound: Any compare-based sorting algorithm must at least <span class="math inline">\(lg(N!) \sim NlgN (Stirling&#39;s formula)\)</span> comparisons in the worst-case</li>
<li>Optimal algorithm：merge sort is an optimal algorithm</li>
</ul></li>
</ul></li>
<li>Merge sort is optimal with respect to number of comparisons but it's not optimal with respect to space usage</li>
<li>Complexity results in context: if more information is provided in terms of the initial order of input, the distribution of key values, or the representation of the keys, lower bound may not hold
<ul>
<li>Partially-ordered array: insertion sort requires only <span class="math inline">\(N - 1\)</span> comparisons if input is sorted</li>
<li>Duplicate keys: three-way quick sort can be used</li>
<li>Digital properties of keys: use digit/character comparisons instead of key comparisons for number and strings, radix sort is used here</li>
</ul></li>
</ul></li>
<li>Comparators
<ul>
<li><p>Comparable interface: sort using a type's natural order</p></li>
<li><p>Comparator interface: sort using an alternate order, the order must be a total order <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span> &lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Key v, Key w)</span></span>;</span><br><span class="line">   <span class="comment">// If v is less than w, then compare(v, w) &lt; 0ssss</span></span><br><span class="line">   <span class="comment">// If v equals to w, then compare(v, w) == 0</span></span><br><span class="line">   <span class="comment">// If v is larger than w, then compare(v, w) &gt; 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Usage in <code>Arrays.sort()</code></p>
<ul>
<li>Create Comparator instance, the instance is an object of a class that implements the Comparator interface</li>
<li>Pass as second argument to <code>Arrays.sort()</code></li>
</ul></li>
</ul></li>
<li>Stability
<ul>
<li>A stable sort preserves the relative order of items with equal keys. If in the original array we have <code>array[i] == array[j], and i &lt; j</code>, then in the sorted array, <code>array[i]</code> should still appear ahead of <code>array[j]</code></li>
<li>Insertion sort and merge sort are stable, selection sort and shell sort are not stable. You need to check how the <code>compareTo()</code> method or the <code>compare()</code> method is implemented<br>
</li>
<li>Insertion sort: we check <code>j &gt; 0 &amp;&amp; items[j].compareTo(items[j - 1]) &lt; 0</code>, so no equal items never move past each other</li>
<li>Selection sort: there may be a long-distance exchange that might move an item past some equal item, here we <code>swap(array[i], array[min]), where min is in &#123;i + 1, ..., array.length - 1&#125;</code></li>
<li>Merge sort: it's stable as long as merge operation is stable, and in the merge function, we have <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (aux[j].compareTo(aux[i]) &lt; <span class="number">0</span>) &#123;              </span><br><span class="line">  items[k] = aux[j++];                  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  items[k] = aux[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> hence if there is an equal situations(<code>aux[j] == aux[i]</code>), we use the left part <code>aux[i]</code> so that we will not change the relative order of <code>aux[i]</code> and <code>aux[j]</code>, therefore it's stable</li>
<li>Shell sort: there is a long-distance exchange in shell sort so it's not stable, we <code>swap(array[j], array[j - h])</code>, there may be values that are equal to <code>array[j - h]</code> in the interval of <code>[j - h + 1, , j - 1]</code>, so it's not stable</li>
<li>Question: <img src="/images/Algorithm/Stability.png">
<ul>
<li>We only need to care about situation where <span class="math inline">\(x_0 = x_1, and \; y_0 = y_1\)</span>, if these points can be put near each other, then it's fine</li>
<li>Choice A: A is fine</li>
<li>Choice B: quick sort x, so x is in order, merge sort y will not change the sorted x since it's stable</li>
<li>Choice C: merge sort x, so x is in order, quick sort y may change the sorted x since it's unstable</li>
<li>Choice D: merge sort is stable</li>
</ul></li>
</ul></li>
<li>Problems:
<ul>
<li>Suppose that the subarray <code>a[0]</code> to <code>a[n - 1]</code> is sorted, and the subarray <code>a[n]</code> to <code>a[2 * n - 1]</code> is sorted. How can you merge the two subarrays so that array a is sorted using an auxiliary array of length n instead of 2n? <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeWithShortAux</span><span class="params">(Comparable[] a, Comparable[] aux)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = a.length / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    aux[i] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">int</span> j = N;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; i &lt; a.length; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; N) &#123;</span><br><span class="line">      a[k++] = a[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; a.length) &#123;</span><br><span class="line">      a[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[j].CompareTo(aux[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      a[k++] = a[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[k++] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>An inversion in an array <code>a[]</code> is a pair of entries <code>a[i]</code> and <code>a[j]</code> such that <code>i &lt; j</code> but <code>a[i] &gt; a[j]</code>. Given an array, design a linearithmic algorithm to count the number of inversions. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Obviously there is an O(n^2) solution, for i in range(len(a)), if a[j] &gt; a[i] for j in range(i + 1, len(a)), then count ++</span></span><br><span class="line"><span class="comment">// The following one is from https://www.youtube.com/watch?v=Vj5IOD7A6f8</span></span><br><span class="line"><span class="comment">//Idea inversion in a = recursive count (left half) + recursive count (right half) + merge count(left + right)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    aux[k] = a[k];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; mid)</span><br><span class="line">          a[k] = aux[j++];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)</span><br><span class="line">          a[k] = aux[i++];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (aux[i].compareTo(aux[j]) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">          a[k] = aux[j++];</span><br><span class="line">          count += mid - i + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          a[k] = aux[i++];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> count1 = sort(a, aux, lo, mid);</span><br><span class="line">    <span class="keyword">int</span> count2 = sort(a, aux, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">int</span> count3 = merge(a, aux, lo, mid, hi);</span><br><span class="line">    <span class="keyword">return</span> count1 + count2 + count3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inverseionCount</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    Comparable[] aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    <span class="keyword">return</span> sort(a, aux, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Quick Sort
<ul>
<li>Introduction
<ul>
<li>Ieda
<ul>
<li>Randomly shuffle the array</li>
<li>Partition the array, so that for some j, <code>array[i]</code> is in place, no larger entry to the left of j, no smaller entry to the right of j</li>
<li>Sort each piece recursively</li>
</ul></li>
<li>Partition
<ul>
<li>Phase I: repeat until i and j pointers cross
<ul>
<li>Scan i from left to right so long as <code>array[i] &lt; array[lo]</code></li>
<li>Scan j from right to left so long as <code>array[j] &gt; array[lo]</code></li>
<li>Exchange <code>array[i]</code> with <code>array[j]</code></li>
</ul></li>
<li>Phase II: when pointers cross.
<ul>
<li>Exchange <code>array[j]</code> with <code>array[lo]</code></li>
</ul></li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (items[++i].compareTo(items[lo]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i == hi) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (items[--j].compareTo(items[lo]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (j == lo) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Comparable item = items[j];</span><br><span class="line">        items[j] = items[lo];</span><br><span class="line">        items[lo] = item;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> j = partition(items, lo, hi);</span><br><span class="line">      sort(items, lo, j - <span class="number">1</span>);</span><br><span class="line">      sort(items, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items)</span> </span>&#123;</span><br><span class="line">      StdRandom.shuffle(items);</span><br><span class="line">      sort(items, <span class="number">0</span>, items.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Implementation Comments
<ul>
<li>The partition in quick sort is in-place, compared with merge sort, quick sort does not take any extra space</li>
<li>Testing whether the pointers cross is a bit trickier than it might seem, especially when there are duplicate keys</li>
<li>Testing <code>j ==lo</code> is redundant, but testing <code>i == hi</code> is not</li>
<li>Random shuffling is needed for performance guarantee</li>
<li>When duplicates are present, it is better to stop on keys equal to the partitioning item's key</li>
</ul></li>
<li>Performance analysis
<ul>
<li>On average, quick sort makes <span class="math inline">\(\sim 2NlogN\)</span> comparisons and <span class="math inline">\(\sim \frac{1}{3}NlogN\)</span> exchanges</li>
<li>In best cases, quick sort makes <span class="math inline">\(\sim NlogN\)</span> comparisons</li>
<li>In worst cases, quick sort makes <span class="math inline">\(\sim \frac{1}{2} N^{2}\)</span> comparisons, randomly shuffling can avoid these situations</li>
</ul></li>
<li>Properties
<ul>
<li>Quick sort is an in-place sorting algorithm</li>
<li>Quick sort is not stable</li>
</ul></li>
</ul></li>
<li>Selection
<ul>
<li>Goal: given an array of <span class="math inline">\(N\)</span> items, find the <span class="math inline">\(k^{th}\)</span> largest</li>
<li>Applications: order statistics, find the top k</li>
<li>Quick-select
<ul>
<li>Partition array so that:
<ul>
<li>Entry <code>array[j]</code> is in place</li>
<li>No larger entry to the left of j</li>
<li>No larger entry to the right of j</li>
</ul></li>
<li>Repeat in one subarray, depending on j; finished when <code>j == k</code></li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">select</span><span class="params">(Comparable[] items, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  StdRandom.shuffle(items);</span><br><span class="line">  <span class="keyword">int</span> lo = <span class="number">0</span>, hi = items.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (hi &gt; lo) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = partition(items, lo, hi);</span><br><span class="line">    <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">      lo = j + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">      hi = j - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> items[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> items[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>Quick-select takes linear time on average</li>
</ul></li>
<li>Duplicate Keys
<ul>
<li>Merge sort with duplicate keys: always between <span class="math inline">\(\frac{1}{2}NlogN\)</span> and <span class="math inline">\(NlogN\)</span> comparisons</li>
<li>Quick sort with duplicate keys: algorithm goes quadratic unless partitioning stops on equal keys</li>
<li>Dijkstra three-way partitioning quick sort
<ul>
<li>Let v be partitioning item <code>items[lo]</code></li>
<li>Scan i from left to right:
<ul>
<li>If <code>items[i] &lt; v</code>: exchange <code>items[lt]</code> with <code>items[i]</code>, increase both lt and i</li>
<li>If <code>items[i] &gt; v</code>: exchange <code>items[gt]</code> with <code>items[i]</code>, decrease gt</li>
<li>If <code>items[i] == v</code>: increase i</li>
</ul></li>
<li>Java implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3Way</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] items, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    Comparable v = items[lo];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">      <span class="keyword">int</span> cmpt = items[i].compareTo(v);</span><br><span class="line">      <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable item = items[i];</span><br><span class="line">        items[i] = items[lt];</span><br><span class="line">        items[lt] = item;</span><br><span class="line">        lt++;</span><br><span class="line">        i++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable item = items[i];</span><br><span class="line">        items[i] = items[gt];</span><br><span class="line">        items[gt] = item;</span><br><span class="line">        gt--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(items, lo, lt - <span class="number">1</span>);</span><br><span class="line">    sort(items, gt + <span class="number">1</span>, hi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Quick sort with 3-way partitioning is entropy-optimal</li>
<li>Randomized quick sort with 3-way partitioning reduces running time from linearithmic to linear in board class of applications</li>
</ul></li>
</ul></li>
<li>System Sorts
<ul>
<li><code>Arrays.sort()</code>
<ul>
<li>Uses tuned quick sort for primitive types; uses tuned merge sort for objects. For objects, merge sort is stable and guarantees <span class="math inline">\(NlogN\)</span> performance, for primitive types, quick sort uses less memory and is faster in generals. If you deliberately create primitive inputs without proper shuffling, the <code>Arrays.sort()</code> with quick sort can fail.</li>
<li>Has different method for each primitive type</li>
<li>Has a method for data types that implements Comparable</li>
<li>Has a method that uses a Comparator</li>
</ul></li>
<li>Which sort to choose
<ul>
<li>Internal sort:
<ul>
<li>Insertion sort, selection sort, bubble sort, shaker sort</li>
<li>Quick sort, merge sort, heap sort, sample sort, shell sort</li>
<li>Solitaire sort, red-black sort, splay sort, Yaroslavskiy sort, psort</li>
</ul></li>
<li>External sort: Poly-phase merge sort, cascade-merge, oscillating sort</li>
<li>String/radix sorts: distribution, MSD, LSD, 3-way string quick sort</li>
<li>Parallel sort:
<ul>
<li>Bitonic sort, Batcher even-odd sort</li>
<li>Smooth sort, cube sort, column sort</li>
<li>GPU sort</li>
</ul></li>
</ul></li>
<li>Application attributes to consider: stable, parallel, deterministic, keys all distinct, multiple key types, linked list or arrays, large or small items, large or small items, is your array randomly ordered, need guarantee performance</li>
<li>Sort summary <img src="/images/Algorithm/SortSummary1.png"></li>
</ul></li>
<li>Problems
<ul>
<li>Selection in two sorted arrays. Given two sorted arrays <code>a[]</code> and <code>b[]</code>, of length <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_2\)</span> and an integer <span class="math inline">\(0 \leq k \leq n_1 + n_2\)</span>, design an algorithm to find a key of rank k.
<ul>
<li>Solution 1: merge <code>a[]</code> and <code>b[]</code> into <code>c[]</code> where c[] is ordered with length <span class="math inline">\(n_1 + n_2\)</span>, pick c[k - 1]</li>
<li>Solution 2: compare <code>a[i]</code> and <code>b[j]</code>, use <code>count</code> to track number of comparisons, if <code>count == k</code>, return <code>a[count]</code> or <code>b[count]</code></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h1 id="week-4">Week 4</h1>
<ol type="1">
<li>Priority Queues
<ul>
<li>API and Elementary Implementations
<ul>
<li><p>API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">  MaxPQ();                   <span class="comment">// create an empty priority queue</span></span><br><span class="line">  MaxPQ(Key[] items);        <span class="comment">// create a priority queue with given keys</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span></span>;        <span class="comment">// insert a key into the priority queue</span></span><br><span class="line">  <span class="function">Key <span class="title">delMax</span><span class="params">()</span></span>;              <span class="comment">// return and remove the largest key</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;         <span class="comment">// is the priority queue empty</span></span><br><span class="line">  <span class="function">Key <span class="title">max</span><span class="params">()</span></span>;                 <span class="comment">// return the largest key</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;                <span class="comment">// number of entries in the priority queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Applications</p>
<ul>
<li>Event-driven simulation: customers in a line</li>
<li>Data compression: huffman codes</li>
<li>Graph searching: Dijkstra's algorithm, Prim's algorithm</li>
<li>AI: A* search</li>
<li>Operating systems: load balancing, interrupt handling</li>
<li>Spam filtering: Bayesian spam filter</li>
</ul></li>
<li><p>Unordered Array Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnorderedMaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Key[] pq;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnorderedMaxPQ</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    pq = (Key[])<span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    pq[N++] = key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pq[i].compareTo(pq[max]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Key item = pq[max];</span><br><span class="line">    pq[max] = pq[N - <span class="number">1</span>];</span><br><span class="line">    pq[N - <span class="number">1</span>] = item;</span><br><span class="line">    <span class="keyword">return</span> pq[--N];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pq[i].compareTo(pq[max]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq[max];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Challenge: implement all operations efficiently</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Implementation</th>
<th style="text-align: center;">insert</th>
<th style="text-align: center;">del max</th>
<th style="text-align: center;">max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">unordered array</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">ordered array</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">goal</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li>Binary Heaps
<ul>
<li><p>Binary tree: empty or node with links to left and right binary trees</p></li>
<li><p>Complete tree: perfectly balanced, except for bottom level</p>
<ul>
<li>Height of complete tree with <span class="math inline">\(N\)</span> nodes is <span class="math inline">\(\left[ logN \right]\)</span></li>
</ul></li>
<li><p>Binary heap: array representation of a heap-ordered complete binary tree</p>
<ul>
<li>Heap-ordered binary tree
<ul>
<li>A binary tree is heap-ordered if the key in each node is larger than (or equal to) the keys in that nodes two children (if any)</li>
<li>The largest key in a heap-ordered binary tree is found at the root</li>
</ul></li>
<li>Array representation
<ul>
<li>Indices start at 1</li>
<li>Take nodes in level order</li>
<li>No explicit links needed</li>
</ul></li>
<li>Can use array indices to move through tree
<ul>
<li>Parent of node at <code>k</code> is at <code>k/2</code></li>
<li>Children of node <code>k</code> are at <code>2 * k</code> and <code>2 * k + 1</code></li>
</ul></li>
<li>Promotion in a heap: child's key becomes than larger than its parent's key
<ul>
<li>Exchange key in a child with key in parent</li>
<li>Repeat until heap order restored <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; pq[k /<span class="number">2</span>].compareTo(pq[k]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    Key item = pq[k / <span class="number">2</span>];</span><br><span class="line">    pq[k / <span class="number">2</span>] = pq[k];</span><br><span class="line">    pq[k] = item;</span><br><span class="line">    k = k / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Insertion in a heap
<ul>
<li>Add node at end, then make promotion if needed</li>
<li>At most <span class="math inline">\(1 + logN\)</span> comparisons <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key value)</span> </span>&#123;</span><br><span class="line">  pq[++N] = value;</span><br><span class="line">  swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Demotion in a heap: parent's key becomes smaller than one(or both) of its children's
<ul>
<li>Exchange key in parent with key in larger child</li>
<li>Repeat until heap order restored <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; N &amp;&amp; pq[j].compareTo(pq[j + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pq[k].compareTo(pq[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Key item = pq[k];</span><br><span class="line">    pq[k] = pq[j];</span><br><span class="line">    pq[j] = item;</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Delete the maximum in a heap
<ul>
<li>Exchange root with node at the end(the smallest one), and then sink it down</li>
<li>At most <span class="math inline">\(2logN\)</span> comparisons, for each level, 2 comparisons are needed, one to find the bigger child, one to determine whether a demotion is needed <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Key max = pq[<span class="number">1</span>];</span><br><span class="line">  pq[<span class="number">1</span>] = pq[N];</span><br><span class="line">  pq[N--] = item;</span><br><span class="line">  sink(<span class="number">1</span>);</span><br><span class="line">  pq[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>Binary Heal Java Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Keyp[] pq;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    pq = (Key[]) <span class="keyword">new</span> Comparable[capacity + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; pq[k /<span class="number">2</span>].compareTo(pq[k]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Key item = pq[k / <span class="number">2</span>];</span><br><span class="line">        pq[k / <span class="number">2</span>] = pq[k];</span><br><span class="line">        pq[k] = item;</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    pq[N++] = key;</span><br><span class="line">    swim(N);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; pq[j].compareTo(pq[j + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pq[k].compareTo(pq[j]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Key item = pq[k];</span><br><span class="line">        pq[k] = pq[j];</span><br><span class="line">        pq[j] = item;</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Key max = pq[<span class="number">1</span>];</span><br><span class="line">    pq[<span class="number">1</span>] = pq[N];</span><br><span class="line">    pq[N--] = max;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    pq[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>Implementation considerations</p>
<ul>
<li>Immutability of keys
<ul>
<li>Immutable data type: cannot change the data type once created</li>
<li>Immutable types: String, Integer, Double, Color, Vector, ...</li>
<li>Mutable: StringBuilder, Stack, Counter, Java Array, ...</li>
</ul></li>
<li>Underflow and overflow: remove when empty, add when full</li>
<li>Minimum-oriented priority queue</li>
<li>Other operations: remove an arbitrary item, change the priority of an item</li>
</ul></li>
<li><p>Priority queue implementation cost summary</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Implementation</th>
<th style="text-align: center;">insert</th>
<th style="text-align: center;">del max</th>
<th style="text-align: center;">max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">unordered array</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">ordered array</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">binary heap</td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">d-ray heap</td>
<td style="text-align: center;"><span class="math inline">\(log_d N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(d \; log_d N\)</span></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Fibonacci</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">impossible</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li>Heap Sort
<ul>
<li>Idea
<ul>
<li>Create max-heap with all N keys using bottom-up method, entries are indexed 1 to N</li>
<li>Repeatedly remove the maximum key</li>
</ul></li>
<li>First pass: build heap using bottom-up method <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] items, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; n &amp;&amp; pq[j].compareTo(pq[j + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable item = pq[k];</span><br><span class="line">    pq[k] = pq[j];</span><br><span class="line">    pq[j] = item;</span><br><span class="line">    k = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// heapify phase, we omit leaves, only consider root of sub-heap</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = n /<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">  sink(pq, k, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Second pass: remove the maximum, once at a time, leave it in array instead of nulling out <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  Comparable item = pq[<span class="number">1</span>];</span><br><span class="line">  pq[<span class="number">1</span>] = pq[N];</span><br><span class="line">  pq[N] = item;</span><br><span class="line">  sink(pq, <span class="number">1</span>, --N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Heap Sort Java Implementation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] pq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = pq.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">      sink(pq, k, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      Comparable item = pq[<span class="number">1</span>];</span><br><span class="line">      pq[<span class="number">1</span>] = pq[N];</span><br><span class="line">      pq[N] = item;</span><br><span class="line">      sink(pq, <span class="number">1</span>, --N);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] items, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">      <span class="keyword">if</span> (j &lt; n &amp;&amp; pq[j].compareTo(pq[j + <span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      Comparable item = pq[k];</span><br><span class="line">      pq[k] = pq[j];</span><br><span class="line">      pq[j] = item;</span><br><span class="line">      k = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Proposition
<ul>
<li>Heap construction uses <span class="math inline">\(\leq 2N\)</span> comparisons and <span class="math inline">\(\leq N\)</span> exchanges</li>
<li>Heap sort uses <span class="math inline">\(\leq 2 N log N + 2 N\)</span> comparisons and <span class="math inline">\(\leq N log N + N\)</span> exchanges</li>
<li>Heap sort is the a in-place sorting algorithm with <span class="math inline">\(N log N\)</span> worst case(given a heap already), merge sort uses linear extra space, quick sort uses quadratic time in worst case</li>
<li>Heap sort is optimal for both time and space, but inner loop is longer than quick sort, it makes poor use of cache memory and it's not stable</li>
</ul></li>
<li>Sort Summary <img src="/images/Algorithm/SortSummary2.png"></li>
</ul></li>
<li>Event-Driven Simulation
<ul>
<li>Goal: simulate the motion of <span class="math inline">\(N\)</span> moving particles that behave according to the laws of elastic collision</li>
<li>Hard sphere model(billiard ball model)
<ul>
<li>N particles in motion, confined in the unit box.</li>
<li>Particle i has known position <span class="math inline">\((rx_i, ry_i)\)</span>, velocity <span class="math inline">\((vx_i, vy_i)\)</span>, mass <span class="math inline">\(m_i\)</span>, and radius <span class="math inline">\(\sigma_i\)</span>.</li>
<li>Particles interact via elastic collisions with each other and with the reflecting boundary.</li>
<li>No other forces are exerted. Thus, particles travel in straight lines at constant speed between collisions.</li>
</ul></li>
<li>Simulation
<ul>
<li>Time-driven simulation: Discretize time into quanta of size <span class="math inline">\(\Delta t\)</span>. Update the position of each particle after every dt units of time and check for overlaps. If there is an overlap, roll back the clock to the time of the collision, update the velocities of the colliding particles, and continue the simulation. For <span class="math inline">\(N\)</span> particles during <span class="math inline">\(\Delta t\)</span> time, the time needed for simulation is proportional to <span class="math inline">\(\frac{N^{2}}{\Delta t}\)</span></li>
<li>Event-driven simulation: We focus only on those times at which interesting events occur, that is to determine the ordered sequence of particle collisions. We maintain a priority queue of future events, ordered by time. At any given time, the priority queue contains all future collisions that would occur, assuming each particle moves in a straight line trajectory forever. As particles collide and change direction, we use lay strategy to remove the invalid events. The simulation process is:
<ul>
<li>Delete the impending event, i.e., the one with the minimum priority t.</li>
<li>If the event corresponds to an invalidated collision, discard it. The event is invalid if one of the particles has participated in a collision since the time the event was inserted onto the priority queue.</li>
<li>If the event corresponds to a physical collision between particles i and j:
<ul>
<li>Advance all particles to time t along a straight line trajectory.</li>
<li>Update the velocities of the two colliding particles i and j according to the laws of elastic collision.</li>
<li>Determine all future collisions that would occur involving either i or j, assuming all particles move in straight line trajectories from time t onwards. Insert these events onto the priority queue.</li>
</ul></li>
<li>If the event corresponds to a physical collision between particles i and a wall, do the analogous thing for particle i.</li>
</ul></li>
</ul></li>
<li>Collision prediction
<ul>
<li><p>Between particle and wall. If a particle with velocity <span class="math inline">\((vx, vy)\)</span> collides with a wall perpendicular to x-axis, then the new velocity is <span class="math inline">\((-vx, vy)\)</span>; if it collides with a wall perpendicular to the y-axis, then the new velocity is <span class="math inline">\((vx, -vy)\)</span></p></li>
<li><p>Between two particles.</p>
<p>At <span class="math inline">\(t\)</span>, we have <span class="math inline">\((rx_i, ry_i)\)</span>, <span class="math inline">\((vx_i, vy_i)\)</span>, <span class="math inline">\(\sigma_i\)</span>, <span class="math inline">\(m_i\)</span>, <span class="math inline">\((rx_j, ry_j)\)</span>, <span class="math inline">\((vx_j, vy_j)\)</span>, <span class="math inline">\(\sigma_j\)</span>, <span class="math inline">\(m_j\)</span>. At <span class="math inline">\(t + \Delta t\)</span>, we have <span class="math inline">\((rx_{i}^{&#39;}, ry_{i}^{&#39;})\)</span>, <span class="math inline">\((vx_{i}^{&#39;}, vy_{i}^{&#39;})\)</span>, <span class="math inline">\(\sigma_{i}\)</span>, <span class="math inline">\(m_i\)</span>, <span class="math inline">\((rx_{j}^{&#39;}, ry_{j}^{&#39;})\)</span>, <span class="math inline">\((vx_{j}^{&#39;}, vy_{j}^{&#39;})\)</span>, <span class="math inline">\(\sigma_j\)</span>, <span class="math inline">\(m_j\)</span></p>
<p><span class="math display">\[rx_{i}^{&#39;} = rx_{i} + \Delta t vx_{i}, \; ry_{i}^{&#39;} = ry_{i} + \Delta t vy_{i} \]</span> <span class="math display">\[rx_{j}^{&#39;} = rx_{j} + \Delta t vx_{j}, \; ry_{j}^{&#39;} = ry_{j} + \Delta t vy_{j} \]</span> <span class="math display">\[vx_{i}^{&#39;} = vx_{i} + \frac{J_{x}}{m_{i}}, \; vy_{i}^{&#39;} = vy_{i} + \frac{J_{y}}{m_{i}} \]</span> <span class="math display">\[vx_{j}^{&#39;} = vx_{j} + \frac{J_{x}}{m_{j}}, \; vy_{j}^{&#39;} = vy_{j} + \frac{J_{y}}{m_{j}} \]</span></p>
<p>where <span class="math inline">\(J = \frac{2m_{i}m_{j}(\Delta v \cdot \Delta r)}{\sigma (m_{i} + m_{j})}\)</span>, <span class="math inline">\(J_{x} = \frac{J\Delta rx}{\sigma}\)</span>, <span class="math inline">\(J_{y} = \frac{J \Delta ry}{\sigma}\)</span>, <span class="math inline">\(\Delta v = (\Delta vx, \Delta vy)\)</span>, <span class="math inline">\(\Delta r = (\Delta rx, \Delta ry)\)</span>, <span class="math inline">\(\sigma = \sigma_{i} + \sigma_{y}\)</span></p></li>
</ul></li>
<li>Java Implementation: I don't put the code here because they are too long, you can find them in the book or on the webpage for the book
<ul>
<li>Particle Class</li>
<li>Event class</li>
<li>CollisionSystem</li>
</ul></li>
<li>Proposition: for <span class="math inline">\(N\)</span> particles, it uses at most <span class="math inline">\(N^{2}\)</span> priority queue operations at initialization, it uses at most <span class="math inline">\(N\)</span> priority queue operations during collision</li>
</ul></li>
</ul></li>
<li>Elementary Symbol Tables
<ul>
<li>Symbol Table API
<ul>
<li>Key-value pair abstraction
<ul>
<li>Insert a value with specified key</li>
<li>Given a key, search for the corresponding value</li>
<li>Examples: dictionary, book index, file share, web search, complier, routing table, DNS, reverse DNS, file system</li>
</ul></li>
<li>Associative array abstraction <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  ST()                                <span class="comment">// create a symbol table</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span>        <span class="comment">// put key-value pair into the table,remove key from table if value is null</span></span></span><br><span class="line"><span class="function">  Value <span class="title">get</span><span class="params">(Key key)</span>                  <span class="comment">// get  value paired with key, null if key is absent</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>                <span class="comment">// remove key and its value from table</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span>           <span class="comment">// is there is a value paired with key</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>                   <span class="comment">// is the table empty</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                          <span class="comment">// number of key-value pairs in the table</span></span></span><br><span class="line"><span class="function">  Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span>                <span class="comment">// all the keys in the table</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>Conventions
<ul>
<li>Values are not null</li>
<li>Method <code>get()</code> returns null if key is not present</li>
<li>Method <code>put()</code> overwrites old value with new value <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  put(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Keys and values
<ul>
<li>Value type: any generic type</li>
<li>Key type:
<ul>
<li>Assume keys are <code>Comparable</code>, use <code>compareTo()</code></li>
<li>Assume keys are any generic type, use <code>equals()</code> to test equality</li>
<li>Assume keys are any generic type, use <code>equals()</code> to test equality, use <code>hashCode()</code> to scramble key, this is built-in in Java</li>
</ul></li>
<li>Best practices: use immutable types for symbol table keys</li>
</ul></li>
<li>Equality test
<ul>
<li>All Java classes inherit a method <code>equals()</code> from <code>Object</code> class</li>
<li>Java requirements, for any references x, y and z
<ul>
<li>Reflexive: <code>x.equals(x)</code> is true</li>
<li>Symmetric: <code>x.equals(y)</code> iff <code>y.equals(x)</code></li>
<li>Transitive: if <code>x.equals(y)</code> and <code>y.equals(z)</code>, then <code>x.equals(z)</code></li>
<li>Non-null: <code>x.equals(null)</code> is false</li>
<li>An equivalence relation: reflexive, symmetric, transitive</li>
</ul></li>
<li>Implementation
<ul>
<li>Default implementation: <code>x == y</code> in <code>Object</code> class</li>
<li>Customized implementation: <code>Integer</code>, <code>Double</code>, <code>String</code>, <code>File</code>, <code>URL</code></li>
<li>User-defined implementation: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object that)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == that) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (that == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != that.getClass()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Type typeThat = (Type) that;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// compare instance fields here</span></span><br><span class="line">  <span class="comment">// for primitive fields, use ==</span></span><br><span class="line">  <span class="comment">// for object fields, use equals</span></span><br><span class="line">  <span class="comment">// for array fields, check equivalence for each entry in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul></li>
<li>Elementary Implementations
<ul>
<li>Linked list with sequential search
<ul>
<li>Maintain a linked list of key-value pairs</li>
<li>Search: scan through all keys until find a match</li>
<li>Insert: scan through all keys until find a match, if not match add to the front</li>
<li>Performance: on average, search <span class="math inline">\(\sim O(N)\)</span>, insert <span class="math inline">\(\sim O(N)\)</span></li>
</ul></li>
<li>Ordered array with binary search
<ul>
<li>Maintain an ordered array of key-value pairs</li>
<li>Search: use binary search to find a key</li>
<li>Insert: need to shift all greater keys over</li>
<li>Performance: on average, search <span class="math inline">\(\sim O(logN)\)</span>, insert <span class="math inline">\(\sim O(N)\)</span></li>
</ul></li>
</ul></li>
<li>Ordered Operations
<ul>
<li><p>Ordered symbol table API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  ST()                                         <span class="comment">// create an ordered symbol table</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span>                 <span class="comment">// put key-value pair into the table,remove key from table is value is null</span></span></span><br><span class="line"><span class="function">  Value <span class="title">get</span><span class="params">(Key key)</span>                           <span class="comment">// value paired with key, null if key absent</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span>                         <span class="comment">// remove key and its value from table</span></span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span>                     <span class="comment">// is there a value paired with key</span></span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>                            <span class="comment">// is the table empty</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                                   <span class="comment">// number of key-value pairs</span></span></span><br><span class="line"><span class="function">  Key <span class="title">min</span><span class="params">()</span>                                    <span class="comment">// smallest key</span></span></span><br><span class="line"><span class="function">  Key <span class="title">max</span><span class="params">()</span>                                    <span class="comment">// largest key</span></span></span><br><span class="line"><span class="function">  Key <span class="title">floor</span><span class="params">(Key key)</span>                           <span class="comment">// largest key less than or equal to key</span></span></span><br><span class="line"><span class="function">  Key <span class="title">ceiling</span><span class="params">(Key key)</span>                         <span class="comment">// smallest key greater than or equal to key</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span>                            <span class="comment">// number or keys less than key</span></span></span><br><span class="line"><span class="function">  Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span>                            <span class="comment">// key of rank k</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span>                             <span class="comment">// delete smallest key</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span>                             <span class="comment">// delete largest key</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> <span class="title">size</span><span class="params">(Key lo, Key hi)</span>                     <span class="comment">// number of keys in [lo..hi]</span></span></span><br><span class="line"><span class="function">  Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo, Key hi)</span>           <span class="comment">// keys in [lo..hi] in sorted order</span></span></span><br><span class="line"><span class="function">  Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span>                         <span class="comment">// all keys in the table in sorted order</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>Performance</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">sequential search</th>
<th style="text-align: center;">binary search</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">search</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">insert/delete</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">min/max</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">floor/ceiling</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">rank</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">select</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">ordered iteration</td>
<td style="text-align: center;"><span class="math inline">\(NlogN\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
</tr>
</tbody>
</table></li>
</ul></li>
<li>Binary Search Trees
<ul>
<li>BST
<ul>
<li>Definition: A BST is a binary tree in symmetric order</li>
<li>It's either empty or two disjoint binary trees(left tree and right tree)</li>
<li>Symmetric order: each node has a key, and every node's key is larger than all keys in its left subtree and smaller than all keys in its right subtree</li>
</ul></li>
<li>BST in Java
<ul>
<li>Definition: A BSt is a reference to a root Node</li>
<li>A Node is comprised of four fields: a Key, a Value, a reference to left and right subtree <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;                    <span class="comment">// sorted by key</span></span><br><span class="line">    <span class="keyword">private</span> Value val;                  <span class="comment">// associated data</span></span><br><span class="line">    <span class="keyword">private</span> Node left, right;           <span class="comment">// left and right subtree</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;                      <span class="comment">// number of nodes in the tree rooted with current node</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.key = key;</span><br><span class="line">      <span class="keyword">this</span>.value = val;</span><br><span class="line">      <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x.size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// helper function, if key not in BST, put key-value pair into BST, else update the value associated with key</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Node x, key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = keu.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      x.left = put(x.left, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      x.right = put(x.right, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">      x.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the recursive calls in the above if-else statements update size with the corresponding node</span></span><br><span class="line">    x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">    root = put(root, key, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// helper function, is key is not int BST, return null, else find the key recursively and return the value paired with key</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> min(x.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(x.right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(root).key;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">    &#125;</span><br><span class="line">    Node t = floor(x.right, key);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">ceiling</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ceiling(x.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    Node t = ceiling(x.left, key);</span><br><span class="line">    <span class="keyword">if</span> (t!= <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = ceiling(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> rank(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> size(x.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> rank(x.right, key) + size(x.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(root, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x.right;</span><br><span class="line">    &#125;</span><br><span class="line">    x.left = deleteMin(x.left);</span><br><span class="line">    x.N = size(x.left) + size(s.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x.left;</span><br><span class="line">    &#125;</span><br><span class="line">    x.right = deleteMax(x.right);</span><br><span class="line">    x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = deleteMax(root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      x.left = delete(x.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      x.right = delete(x.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.left;</span><br><span class="line">      &#125;</span><br><span class="line">      Node temp = x;</span><br><span class="line">      x = min(temp.right);</span><br><span class="line">      x.right = deleteMin(temp.right);</span><br><span class="line">      x.left = temp.left;</span><br><span class="line">    &#125;</span><br><span class="line">    x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    root = delete(root, key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node x, Queue&lt;Key&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(x.left, queue);</span><br><span class="line">    queue.enqueue(x);</span><br><span class="line">    inorder(x.right, queue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;&lt;Key&gt;();</span><br><span class="line">    inorder(root, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Search: if less, go left; if greater, go right; if equal, search hit. If null but not hit, search miss</li>
<li>Insert: if less, go left; if greater, go right; if null, insert, if old value exists, update it to new value</li>
<li>Performance: on average, search <span class="math inline">\(\sim O(logN) (\sim 1.39 logN)\)</span>, insert <span class="math inline">\(\sim O(logN) (\sim 1.39 logN)\)</span></li>
</ul></li>
</ul></li>
<li>Ordered Operations in BSTs
<ul>
<li>Operations
<ul>
<li>Minimum: smallest key in the table, the leftmost one</li>
<li>Maximum: largest key in the table, the rightmost one</li>
<li>Floor: largest key <span class="math inline">\(\leq\)</span> to a given key, if <code>key == root.key</code>, result is <code>root.key</code>, if <code>key &lt; root.key</code>, result is in the left subtree, if <code>key &gt; root.key</code>, result is in the right subtree</li>
<li>Ceiling: smallest key <span class="math inline">\(\geq\)</span> to a given key, if <code>key == root.key</code>, result is <code>root.key</code>, if <code>key &gt; root.key</code>, result is in the left subtree, if <code>key &lt; root.key</code>, result is in the right subtree</li>
<li>Rank: number of keys in the symbol table strictly less than</li>
<li>In-order traversal: maintain a queue, traverse left subtree, enqueue key, traverse right subtree</li>
</ul></li>
</ul></li>
<li>Deletion in BSTs
<ul>
<li>Lazy approach deletion
<ul>
<li>To remove a node with a give key:
<ul>
<li>Set its value to <code>null</code></li>
<li>Leave key in tree to guide searches</li>
</ul></li>
<li>Cost: <span class="math inline">\(\sim 2logN\)</span> per insertion, search, and deletion</li>
</ul></li>
<li>Delete the minimum:
<ul>
<li>To delete the minimum key:
<ul>
<li>Go left until finding a node with a null left link</li>
<li>Replace that node by its right link</li>
<li>Update subtree counts</li>
</ul></li>
</ul></li>
<li>Hibbard deletion: delete a node with key k: search for node t containing key k
<ul>
<li>Node t has 0 children: delete t by setting parent link to null</li>
<li>Node t has 1 child: delete t by replacing parent link to t with parent link to t's child</li>
<li>Node t has 2 children:
<ul>
<li>Find the minNode in the right subtree of t</li>
<li>Replace t with minNode</li>
<li>New t's right subtree is the right subtree of old t without minNode</li>
<li>New t's left subtree is the left subtree of old t</li>
<li>Update size of t</li>
</ul></li>
<li>Performance: on average, if deletion is allowed, then search, insertion and deletion all become <span class="math inline">\(\sim \sqrt{N}\)</span>. But for Red-Black BSTs guarantee logarithm cost for all the three operations.</li>
</ul></li>
</ul></li>
<li>Problems
<ul>
<li>Auto-boxing <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> b = -<span class="number">0.0</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">System.out.println(Double.valueOf(a) == Double.valueOf(b)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> c = Double.NaN;</span><br><span class="line"><span class="keyword">double</span> d = Double.NaN;</span><br><span class="line"></span><br><span class="line">System.out.println(c == d); <span class="comment">// false</span></span><br><span class="line">System.out.println(Double.valueOf(c) == Double.valueOf(d)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>isBST <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isBSTHelper(root, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">isBSTHelper</span><span class="params">(Node node, <span class="keyword">int</span> minVal, <span class="keyword">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.key &lt; minVal || node.key &gt; maxVal) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isBSTHelper(node.left, minVal - <span class="number">1</span>, maxVal) &amp;&amp; isBSTHelper(node.right, minVal, maxVal - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Inorder traversal
<ul>
<li>Recursion approach <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  inorder(x.left);</span><br><span class="line">  System.out.println(x);</span><br><span class="line">  inorder(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Iteration with stack approach <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Node&gt;();</span><br><span class="line">  Node current = root;</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty() || current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.addLast(node);</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Node temp = stack.removeLast();</span><br><span class="line">      System.out.println(node);</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Morris traversal: no recursion, no stack
<ul>
<li>Algorithm
<ul>
<li>Initialize the root as the current node <code>curr</code></li>
<li>While <code>curr</code> is not null, check if <code>curr</code> has a left child</li>
<li>If <code>curr</code> does not have a left child, print <code>curr</code> and update it to <code>curr.right</code></li>
<li>Else, make <code>curr</code> the right child of the rightmost node in <code>curr</code>'s left subtree(the rightmost node in <code>curr</code>'s left subtree is the inorder predecessor, we give it a link to <code>curr</code> if there is no link, and we remove the link if there has already been one)</li>
<li>Update <code>curr</code> to his left node</li>
</ul></li>
<li>Video: <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wGXB9OWhPTg">https://www.youtube.com/watch?v=wGXB9OWhPTg</a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node root)</span> </span>&#123; </span><br><span class="line">  Node curr, prev; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">  curr = root; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (curr.left == <span class="keyword">null</span>) &#123; </span><br><span class="line">      System.out.print(curr.key); </span><br><span class="line">      curr = curr.right; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">// find the prev of curr </span></span><br><span class="line">      prev = curr.left; </span><br><span class="line">      <span class="comment">// for the first time, prev.right !=null is termination, for the second time, prev.right != current is termination</span></span><br><span class="line">      <span class="keyword">while</span> (prev.right != <span class="keyword">null</span> &amp;&amp; prev.right != curr) </span><br><span class="line">        prev = prev.right; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// first time, link prev to current</span></span><br><span class="line">      <span class="keyword">if</span> (prev.right == <span class="keyword">null</span>) &#123; </span><br><span class="line">        prev.right = curr; </span><br><span class="line">        curr = curr.left; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// second time, remove the link</span></span><br><span class="line">      <span class="keyword">else</span> &#123; </span><br><span class="line">        prev.right = <span class="keyword">null</span>; </span><br><span class="line">        System.out.print(curr.key); </span><br><span class="line">        curr = curr.right; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h1 id="week-5">Week 5</h1>
<ol type="1">
<li>Balanced Search Trees
<ul>
<li>2-3 Search Trees
<ul>
<li>Allow 1 or 2 keys per node:
<ul>
<li>2-node: one key <code>key0</code>, two children, key(keys) on the left child should be smaller than <code>key0</code>, key(keys) on the right child should be larger than <code>key0</code></li>
<li>3-node: two keys <code>key0</code> and <code>key1</code> (<code>key0 &lt; key1</code>), three children, key(keys) on the left child should be smaller than <code>key0</code>, key(keys) on the middle child should be between <code>key0</code>and <code>key1</code>, key(keys) on the right child should be larger than <code>key1</code></li>
</ul></li>
<li>Perfect balance: every path from root to null link has the same length</li>
<li>Symmetric order: inorder traversal yields keys in ascending order</li>
<li>Search
<ul>
<li>Compare search key against keys in node</li>
<li>Find interval containing search key</li>
<li>Follow associated link recursively</li>
</ul></li>
<li>Insert into a 2-node at bottom
<ul>
<li>Search for key as usual</li>
<li>Replace 2-node with 3-node</li>
</ul></li>
<li>Insert into a 3-node at bottom
<ul>
<li>Add new key to 3-node to create temporary 4-node</li>
<li>Move middle key in 4-node into parent, the temporary 4-node split into three 2-node</li>
<li>Repeat up the tree, as necessary(if parent is already a 3-node)</li>
<li>If you reach the root and it's a 4-node, split in into three 2-nodes, the middle one becomes the new root, the left and right one become the first two children</li>
</ul></li>
<li>Splitting a 4-node is a local transformation, it involves only constant number of operations</li>
<li>Global properties in a 2-3 tree: 2-3 tree maintains symmetric order and perfect balance</li>
<li>Performance: every path from root to null link has the same length</li>
<li>Tree height:
<ul>
<li>Worst case all 2-nodes: <span class="math inline">\(log_{2} N\)</span></li>
<li>Best case all 3-nodes: <span class="math inline">\(log_{3} N \approx 0.631 log_{2}N\)</span></li>
<li>Between 12 and 20 for a million nodes</li>
<li>Between 18 to 30 for a billion nodes</li>
<li>Guaranteed logarithmic performance for search and insert</li>
</ul></li>
<li>Direct implementation could be complicated</li>
</ul></li>
<li>Red-Black BSTs
<ul>
<li>Paper: Guibas-Sedgewick 1979 and Sedgewick 2007</li>
<li>Easy implementation of 2-3 tree:
<ul>
<li>Represent 2-3 tree as a BST</li>
<li>Use internal left-leaning link as glue for 3-nodes <img src="/images/Algorithm/RBT3Node.png"></li>
<li>Black links connect 2-nodes and 3-nodes, red links glue nodes within a 3-node</li>
<li>Definition: a BST such that
<ul>
<li>No node has two read links connected to it</li>
<li>Perfect black balance: every path from root to null link has the same number of black links</li>
<li>Red links lean left</li>
</ul></li>
</ul></li>
<li>Key property: 1-1 correspondence between 2-3 and LLRB(Left-Leaning Red-Black Tree)
<ul>
<li>Make each red links in LLRB horizontal and replace melt the associated 2-nodes into 3-nodes, the result is a 2-3 tree</li>
</ul></li>
<li>Search implementation: search is the same as for elementary BST(ignore color)<br>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Val <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  Node x = root;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      x = x.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      x = x.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>RBT representation
<ul>
<li>Since each node is pointed to by precisely one link from its parent, we can encode color of links in nodes <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Key key;</span><br><span class="line">  <span class="keyword">private</span> Value val;</span><br><span class="line">  <span class="keyword">private</span> Node left, right;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> color;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">boolean</span> color, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.color == RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Left rotation: orient a temporarily right-leaning red link to lean left
<ul>
<li>Idea: oldRoot =&gt; newRoot.left, oldRoot.right =&gt; newRoot <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">  Node temp = x.right;</span><br><span class="line">  x.right = temp.left;</span><br><span class="line">  temp.left = x;</span><br><span class="line">  temp.color = x.color;</span><br><span class="line">  x.color = RED;</span><br><span class="line">  temp.size = x.size;</span><br><span class="line">  x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Invariants: maintains symmetric order and perfect black balance</li>
</ul></li>
<li>Right rotation: orient a left-leaning read link to temporarily lean right
<ul>
<li>Idea: oldRoot =&gt; newRoot.right, oldRoot.left =&gt; newRoot <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">  Node temp = x.left;</span><br><span class="line">  x.left = temp.right;</span><br><span class="line">  temp.right = x;</span><br><span class="line">  temp.color = x.color;</span><br><span class="line">  x.color = RED;</span><br><span class="line">  temp.size = x.size;</span><br><span class="line">  x.size = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Invariants: maintains symmetric order and perfect black balance</li>
</ul></li>
<li>Color flip: recolor to split a temporary 4-node
<ul>
<li>Idea: middleNode.color: black =&gt; red, leftNode.color: red =&gt; black, rightNode.color: red =&gt; black <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> !isRed(x);</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(x.left)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(x.right)</span></span>;</span><br><span class="line">  x.color = RED;</span><br><span class="line">  x.left.color = BLACK;</span><br><span class="line">  x.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Invariants: maintains symmetric order and perfect black balance</li>
</ul></li>
<li>Insertion in a LLRB tree：
<ul>
<li>Basic strategy: maintain 1-1 correspondence with 2-3 trees by applying elementary red-black BST operations</li>
<li>Every time you insert a new node, it creates a red link with its parent</li>
<li>Case 1: insert into a 2-node at the bottom
<ul>
<li>Prerequisite: insert into a tree with exactly 1 node <img src="/images/Algorithm/BST1NodeInsertion.png"></li>
<li>Steps of insertion:
<ul>
<li>Do standard BST insert, color new link red</li>
<li>If new red link is a right link, do left rotation</li>
</ul></li>
</ul></li>
<li>Case 2: insert into a 3-node at the bottom
<ul>
<li>Prerequisite: insert into a tree with exactly 2 nodes <img src="/images/Algorithm/BST2NodeInsertion.pngs"></li>
<li>Steps of insertion:
<ul>
<li>Do standard BST insertion, color new link red</li>
<li>Rotate to balance the 4-node if needed</li>
<li>Flip colors to pass red link up one level</li>
<li>Rotate to make lean left if needed</li>
<li>Repeat case 1 or 2 up the tree if needed</li>
</ul></li>
</ul></li>
<li>Java implementation
<ul>
<li>Handle all cases:
<ul>
<li>Right child red, left child black: left rotation</li>
<li>Left child, left-left grandchild red: right rotation</li>
<li>Both children red: flip colors</li>
</ul></li>
<li>Java code <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node, Key key, Value val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">  <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    node.left = put(node.left, key, val);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    node.right = put(node.right, key, val);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">    node.val = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">    node = rotateLeft(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">    node = rotateRight(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">    flipColors(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li>Preposition: height or LLRB trees is <span class="math inline">\(\leq 2logN\)</span> in the worst case</li>
<li>Performance analysis:<br>
<img src="/images/Algorithm/BSTPerformance.png"></li>
</ul></li>
<li>B-Trees
<ul>
<li>Definition: generalize 2-3 trees by allowing up to <span class="math inline">\(M - 1\)</span> key-link pairs per node
<ul>
<li>At least 2 key-link pairs at root</li>
<li>At least <span class="math inline">\(M / 2\)</span> key-link pairs in other nodes</li>
<li>External nodes contain client keys</li>
<li>Internal nodes contain copies of keys to guide search</li>
</ul></li>
<li>Searching in a B-tree
<ul>
<li>Start at root</li>
<li>Find interval for search key and take corresponding link</li>
<li>Search terminates in external node</li>
</ul></li>
<li>Insertion in a B-tree
<ul>
<li>Search for new key</li>
<li>Insert at bottom</li>
<li>Split nodes with M key-link pairs on the way up the tree</li>
</ul></li>
<li>Balance in B-tree
<ul>
<li>Preposition: a search or an insertion in a B-tree of order <span class="math inline">\(M\)</span> with <span class="math inline">\(N\)</span> keys requires between <span class="math inline">\(log_{2} {M - 1}\)</span> and <span class="math inline">\(log_{M / 2} {N}\)</span> probs</li>
<li>In practice, number of probs is at most 4(M = 1024, N = 62 billion, <span class="math inline">\(log_{M/2} {N} \leq 4\)</span>)</li>
<li>Optimization: always keep root page in memory</li>
</ul></li>
<li>Balanced trees in the wild
<ul>
<li>Red-black trees are widely used as system symbol tables
<ul>
<li>Java: <code>java.util.TreeMap</code>, <code>java.util.TreeSet</code></li>
<li>C++ STL: map, multimap, multiset</li>
<li>Linux kernel: completely fair schedule, linux/rbtree.h</li>
<li>Emacs: conservative stack scanning</li>
</ul></li>
<li>B-tree variants: B+ tree, B* tree, B# tree</li>
<li>B-trees and variants are widely used for file systems and databases
<ul>
<li>Windows: NTFS</li>
<li>Mac: HFS, HFS+</li>
<li>Linux: ReiserFS, XFS, Ext3FS, JFS</li>
<li>Databases: ORACLE, DB2, INGRES, SQL, PostgreSQL</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>Geometric Applications of BSTs
<ul>
<li>1d Range Search
<ul>
<li><p>Extension of ordered symbol table</p>
<ul>
<li>Insert key-value pair</li>
<li>Search for key <span class="math inline">\(k\)</span></li>
<li>Delete key <span class="math inline">\(k\)</span></li>
<li>Range search: find all keys between <span class="math inline">\(K_1\)</span> and <span class="math inline">\(k_2\)</span></li>
<li>Range count: number of keys between <span class="math inline">\(k_1\)</span> and <span class="math inline">\(k_2\)</span></li>
</ul></li>
<li><p>Application: database queries</p></li>
<li><p>Geometric interpretation</p>
<ul>
<li>Keys are point on a line</li>
<li>Find/count points in a given 1d interval</li>
</ul></li>
<li><p>Implementation:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">data structure</th>
<th style="text-align: center;">insert</th>
<th style="text-align: center;">range count</th>
<th style="text-align: center;">range search</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">unordered array</td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">ordered array</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;"><span class="math inline">\(R + logN\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">goal</td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;"><span class="math inline">\(logN\)</span></td>
<td style="text-align: center;"><span class="math inline">\(R + logN\)</span></td>
</tr>
</tbody>
</table>
<p>N = number of keys, R = number of keys that match</p></li>
<li><p>1d range search: BST implementation</p>
<ul>
<li>Find all keys between <code>lo</code> and <code>hi</code>
<ul>
<li>Recursively find all keys in left subtree if any could fall in range</li>
<li>Check key in current node</li>
<li>Recursively find all keys in right subtree if any could fall in range</li>
</ul></li>
<li>Preposition: running time proportional to <span class="math inline">\(R + log N\)</span><br>
</li>
</ul></li>
</ul></li>
<li>Linear Segment Insertion
<ul>
<li>Orthogonal line segment insertion search: given <span class="math inline">\(N\)</span> horizontal and vertical line segments, find all intersections. Non-degeneracy assumption: all x- and y- coordinates are distinct
<ul>
<li>Quadratic algorithm: check all pairs of line segments for intersection</li>
<li>Sweep-line algorithm: sweep vertical line from left to right
<ul>
<li>x-coordinate define events</li>
<li>horizontal-segment(left endpoint): insert y-coordinate into BST</li>
<li>horizontal-segment(right endpoint): remove y-coordinate from BST</li>
<li>vertical-segment: range search for interval of y-endpoints</li>
</ul></li>
<li>Preposition: the sweep-line algorithm takes time proportional to <span class="math inline">\(N log N + R\)</span> to find all <span class="math inline">\(R\)</span> intersections among <span class="math inline">\(N\)</span> orthogonal line segments</li>
</ul></li>
</ul></li>
<li>Kd-Trees
<ul>
<li>2d orthogonal range search
<ul>
<li>Extension of ordered symbol-table to 2d keys
<ul>
<li>Insert a 2d key</li>
<li>Delete a 2d key</li>
<li>Search for a 2d key</li>
<li>Range search: find all keys that lie in a 2d range</li>
<li>Range count: number of keys that lie in a 2d range</li>
</ul></li>
<li>Geometric interpretation
<ul>
<li>Keys are point in the plane</li>
<li>Find/count points in a given h-v rectangle</li>
</ul></li>
<li>Applications: networking, circuit design, databases</li>
<li>2d orthogonal range search: grid implementation
<ul>
<li>Divide space into M-by-M grid of squares</li>
<li>Create list of points contained in each square</li>
<li>Use 2d array to directly index relevant square</li>
<li>Insert: <code>add(x,y)</code> to list for corresponding square</li>
<li>Range search: examine only squares that intersect 2d range query</li>
</ul></li>
<li>Grid implementation is a fast and simple solution for evenly-distributed points, but it does not perform well for when clustering appears</li>
</ul></li>
<li>Space-partitioning trees
<ul>
<li>Use a tree to represent a recursive subdivision of 2d space</li>
<li>Grid: divide space uniformly into squares</li>
<li>2d tree: recursively divide space into two half-planes</li>
<li>Quadtree: recursively divide space into four quadrants</li>
<li>BSP tree: recursively divide space into two regions</li>
<li>Applications: Ray tracing, 2d range search, nearest neighbor search, collision detections, adaptive mesh generation</li>
</ul></li>
<li>2d tree
<ul>
<li>Data structure: BST, but alternate using x- and y-coordinates as key
<ul>
<li>Search gives rectangle containing point</li>
<li>Insert further subdivides the plane</li>
</ul></li>
<li>Construction
<ul>
<li>First level vertical node and then horizontal nodes and then vertical nodes,...</li>
<li>On the left of previous node =&gt; left subtree, on the right of previous node =&gt; right subtree</li>
</ul></li>
<li>Range search in a 2d tree: find all points in a query axis-aligned rectangle
<ul>
<li>Check if point in node lies in given rectangle</li>
<li>Recursively search left/bottom if any could fall in rectangle</li>
<li>Recursively search right/top if any could fall in rectangle</li>
</ul></li>
<li>Range search performance in a 2d tree
<ul>
<li>Typical case: <span class="math inline">\(R + log N\)</span></li>
<li>Worst case: <span class="math inline">\(R + \sqrt{N}\)</span></li>
</ul></li>
<li>Nearest neighbor search in a 2d tree: find closest point to the query point
<ul>
<li>Algorithm
<ul>
<li>Check distance from point in node to the query point</li>
<li>Recursively search left/bottom if it could contain a closer point</li>
<li>Recursively search right/top if it could contain a closer point</li>
<li>Organize method so that it starts from root</li>
</ul></li>
</ul></li>
</ul></li>
<li>Flocking boids [Craig Reynolds, 1986]
<ul>
<li>Boids, three simple rules lead to complex emergent flocking behavior
<ul>
<li>Collision avoidance: point away from k nearest boids</li>
<li>Flock centering: point towards the center of mass of k nearest boids</li>
<li>Velocity matching: update velocity to the average of k nearest boids</li>
</ul></li>
<li>Kd tree: recursively partition k-dimensional space into 2 half-spaces
<ul>
<li>Implementation: BST, but cycle through dimensions ala 2d trees</li>
</ul></li>
</ul></li>
</ul></li>
<li>Interval Search Trees
<ul>
<li>1d interval search: data structure to hold set of overlapping intervals
<ul>
<li>Insert an interval <code>(lo, hi)</code></li>
<li>Search for an interval <code>(lo, hi)</code></li>
<li>Delete an interval <code>(lo, hi)</code></li>
<li>Interval intersection query: given an interval <code>(lo, hi)</code>, find all intervals in data structure that intersects <code>(lo, hi)</code></li>
</ul></li>
<li>1d interval search API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntervalST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  IntervalST();                                 <span class="comment">// create interval search tree</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key lo, Key hi, Value val)</span></span>;          <span class="comment">// put interval-value pair into ST </span></span><br><span class="line">  <span class="function">Value <span class="title">get</span><span class="params">(Key lo, Key hi)</span></span>;                    <span class="comment">// value paired with given interval</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key lo, Key hi)</span></span>;                  <span class="comment">// delete the given interval</span></span><br><span class="line">  <span class="function">Iterable&lt;Value&gt; <span class="title">intersects</span><span class="params">(Key lo, Key hi)</span></span>;   <span class="comment">// all intervals that intersect the given interval</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Construction
<ul>
<li>BST each nodes contains an interval <code>(lo, hi)</code>, use left endpoint as BST key</li>
<li>Store max endpoint in subtree rooted at node</li>
</ul></li>
<li>Insert an interval <code>(lo, hi)</code>
<ul>
<li>Insert into BST, using <code>lo</code> as the key</li>
<li>Update max in each node on search path</li>
</ul></li>
<li>Find interval that intersects query interval <code>(lo, hi)</code>
<ul>
<li>If interval in node intersects query interval, return it</li>
<li>Else if left subtree is null, go right</li>
<li>Else is max endpoint in left subtree is less than <code>lo</code>, go right</li>
<li>Else go left</li>
</ul></li>
</ul></li>
<li>Interval search tree performance analysis</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">operation</th>
<th style="text-align: center;">brute</th>
<th style="text-align: center;">interval search tree</th>
<th style="text-align: center;">best in memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">insert interval</td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find interval</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">delete interval</td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">find any one interval <br>that intersects <code>(lo, hi)</code></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(log N\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">find all intervals <br>that intersects <code>(lo, hi)</code></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(R log N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(R + log N\)</span></td>
</tr>
</tbody>
</table></li>
<li>Rectangle Intersection
<ul>
<li>Orthogonal rectangle intersection search: find all intersections among a set of <span class="math inline">\(N\)</span> orthogonal rectangles, assume all x- and y-coordinates are distinct</li>
<li>Use sweep-line algorithm to reduce the problem to 1d interval search</li>
<li>Proposition: sweep-line algorithm takes time proportional to <span class="math inline">\(N log N + R log N\)</span> to find <span class="math inline">\(R\)</span> intersections among a set of <span class="math inline">\(N\)</span> rectangles</li>
</ul></li>
</ul></li>
</ol>
<h1 id="week-6">Week 6</h1>
<ol type="1">
<li>Hash Tables
<ul>
<li>Hash Tables
<ul>
<li>Hashing: save items in a key-indexed table
<ul>
<li>Hash function: method for computing array index from key</li>
<li>Issues:
<ul>
<li>Computing the hash function</li>
<li>Equality test: method for checking whether two keys are equal</li>
<li>Collision resolution: algorithm and data structure to handle two keys that hash to the same array index</li>
</ul></li>
<li>Computing the hash function
<ul>
<li>Idealistic goal: scramble the keys uniformly to produce a table index
<ul>
<li>Efficiently computable</li>
<li>Each table index equally likely for each key</li>
</ul></li>
<li>Java <code>hashCode()</code> function:
<ul>
<li>Requirement: if <code>x.equals(y)</code>, then <code>x.hashCode() == y.hashCode()</code></li>
<li>Highly desirable: if <code>!x.equals(y)</code>, then <code>x.hashCode() != y.hashCode()</code></li>
<li>Default implementation: memory address of x</li>
<li>Customized implementations: Integer, Double, String, File, URL, Date, ...</li>
<li>String: <span class="math inline">\(hash = s[0] * 31^{L - 1} + ... + s[L - 1] * 31 ^{0}\)</span></li>
<li>User-defined types: users are on their own, a sample hash: <span class="math inline">\(hash = initialHash + \sum\limits_i {field_i.hashCode()}\)</span></li>
</ul></li>
<li>Modular hashing
<ul>
<li>Hash Code: an int between <span class="math inline">\(- 2^{31}\)</span> and <span class="math inline">\(2^{31} - 1\)</span></li>
<li>Hash function: an int between <span class="math inline">\(0\)</span> and <span class="math inline">\(M - 1\)</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong, may be negative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key.hashCode() % M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wrong, Math.abs() cannot convert - 2 ^31 to 2^31, because Integer.MAX_VALUE is 2 ^31 - 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Math.abs(key.hashCode()) % M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Right choice, use 0x7fffffff to remove sign</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Uniform hashing function: each key is equally likely to hash to an integer between <span class="math inline">\(0\)</span> and <span class="math inline">\(M - 1\)</span>
<ul>
<li>Bins and balls: throw balls uniformly at random into M bins
<ul>
<li>Birthday problem: expect two balls in the same bin after <span class="math inline">\(\sim \; \sqrt{\pi M / 2}\)</span> tosses</li>
<li>Coupon collector: expect every bin has <span class="math inline">\(\geq 1\)</span> ball after <span class="math inline">\(\sim \; M ln M\)</span> tosses</li>
<li>Load balancing: After M tosses, expect most loaded bin has <span class="math inline">\(\Theta(logM / log log M)\)</span> balls</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>Separate Chaining
<ul>
<li>Collisions: two distinct keys hashing to same index
<ul>
<li>Birthday problem: cannot avoid collisions unless you have a ridiculous amount of memory</li>
<li>Coupon collector + load balancing: collisions will be evenly distributed</li>
</ul></li>
<li>Separate chaining symbol table: use an array of <span class="math inline">\(M &lt; N\)</span> linked lists [H. P. Luhn, IBM 1953]
<ul>
<li>Hash: map key to integer i between <span class="math inline">\(0\)</span> and <span class="math inline">\(M - 1\)</span></li>
<li>Insert: put at front of <span class="math inline">\(i^{th}\)</span> chain if not already here</li>
<li>Search: need to search only <span class="math inline">\(i^{th}\)</span> chain</li>
</ul></li>
<li>Proposition: under uniform hashing assumption, prob that the number of keys in a list is within a constant factor of <span class="math inline">\(N/M\)</span> is extremely close to 1</li>
<li>ST implementation: summary <img src="/images/Algorithm/SeparateChaining.png"></li>
</ul></li>
<li>Linear Probing
<ul>
<li>Collision resolution: open addressing [Amdahl-Boehme-Rocherster-Samuel, IBM 1953]
<ul>
<li>When a new key collides, find next empty slot, and put it there. Put at table index <code>i</code> if free, if not try <code>i + 1</code>, <code>i + 2</code>, etc.</li>
<li>The size M must be greater than number of key-value pairs N, in practice, <span class="math inline">\(M \geq N * 2\)</span></li>
</ul></li>
<li>Clustering
<ul>
<li>A cluster is a contiguous block of items</li>
<li>New keys likely to hash into middle of big clusters</li>
</ul></li>
<li>Proposition: under uniform hashing assumption, the average # of probes in a linear probing hash table of size <span class="math inline">\(M\)</span> that contains <span class="math inline">\(N = \alpha M\)</span> keys is: <span class="math inline">\(\sim \frac{1}{2}(1 + \frac{1}{1-\alpha})\)</span> for search hit, and <span class="math inline">\(\sim \frac{1}{2}(1 + \frac{1}{(1- \alpha)^{2}})\)</span> for search miss or insert. And the typical choice is that <span class="math inline">\(\alpha = M / N \approx \frac{1}{2}\)</span></li>
<li>ST implementation: summary <img src="/images/Algorithm/LinearProbing.png"></li>
</ul></li>
<li>Hash Table Context
<ul>
<li>Java 1.1 use skip hashCode in String type, it's unsafe to do so</li>
<li>Algorithm complexity attacks
<ul>
<li>Uniform hashing assumption is important: aircraft control, nuclear reactor, pacemaker</li>
<li>Denial-of-service attacks</li>
<li>Diversion: one-way hash functions
<ul>
<li>Hard to find a key that will hash to a desired value</li>
<li>Applications: digital fingerprint, message digest, storing passwords</li>
</ul></li>
<li>Hashing variations:
<ul>
<li>Two-probe hashing</li>
<li>Double hashing</li>
<li>Cuckoo hashing</li>
</ul></li>
<li>BST v.s. Hash tables
<ul>
<li>Hash tables
<ul>
<li>Simpler to code</li>
<li>No effective alternative for unordered keys</li>
<li>Faster for simple keys</li>
<li>Better system support in Java for strings</li>
</ul></li>
<li>BST
<ul>
<li>Stronger performance guarantee</li>
<li>Support for ordered ST operations</li>
<li>Easier to implement <code>compareTo()</code> correctly than <code>equals()</code> and <code>hashCode()</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li>Symbol Table Applications
<ul>
<li>Sets: a collection of distinct keys
<ul>
<li>API <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SET</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create empty set</span></span><br><span class="line">  SET();</span><br><span class="line">  <span class="comment">// add the key to the set</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Key key)</span></span>;</span><br><span class="line">  <span class="comment">//is the key in the set?</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>;</span><br><span class="line">  <span class="comment">// remove the key from the set</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>;</span><br><span class="line">  <span class="comment">// return the number of keys in the set</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// iterator through keys in the set</span></span><br><span class="line">  <span class="function">Iterator&lt;Key&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>Dictionary Clients
<ul>
<li>Build a client to map key to its associated value</li>
</ul></li>
<li>Indexing Clients
<ul>
<li>Given a list of files specified, create an index so that you can efficiently find all files containing a given query string</li>
</ul></li>
<li>Sparse Vectors
<ul>
<li>For matrix vector multiplication, you can use <span class="math inline">\(O(N^{2})\)</span> for loop.</li>
<li>Sparse vector: use symbol table representation(key = index, value = entry) rather than an array can be efficient(array representation space is proportional to N, ST representation is proportional to # of non-zeroes)</li>
<li>Sparse matrix: each row is a sparse vector rather than an array, space is then proportional to number of non-zeroes plus N rather than <span class="math inline">\(N^{2}\)</span></li>
</ul></li>
</ul></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Yanxuanshaozhu
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://yanxuanshaozhu.github.io/2021/04/16/Princeton%20Algorithms%20Part%20One%20Notes/" title="Princeton Algorithms Part One Notes">https://yanxuanshaozhu.github.io/2021/04/16/Princeton Algorithms Part One Notes/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm-Part-One/" rel="tag"># Algorithm Part One</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/03/Build%20a%20Modern%20Computer%20from%20First%20Principles%20Part%20One%20Notes/" rel="prev" title="Build a Modern Computer from First Principles Part One Notes">
      <i class="fa fa-chevron-left"></i> Build a Modern Computer from First Principles Part One Notes
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/19/Introduction%20to%20Machine%20Learning%20Notes/" rel="next" title="Introduction to Machine Learning Notes">
      Introduction to Machine Learning Notes <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#week-1"><span class="nav-number">1.</span> <span class="nav-text">Week 1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#week-2"><span class="nav-number">2.</span> <span class="nav-text">Week 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#week-3"><span class="nav-number">3.</span> <span class="nav-text">Week 3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#week-4"><span class="nav-number">4.</span> <span class="nav-text">Week 4</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#week-5"><span class="nav-number">5.</span> <span class="nav-text">Week 5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#week-6"><span class="nav-number">6.</span> <span class="nav-text">Week 6</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yanxuanshaozhu"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Yanxuanshaozhu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yanxuanshaozhu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanxuanshaozhu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mrlixm.cn@gmail.com" title="E-Mail → mailto:mrlixm.cn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanxuanshaozhu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">332k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:02</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
